 
‚úÖ SQL Injection - Prepared statements no Database //S√≥ o Database protege contra SQL Injection

‚úÖ CONTRA XSS NO FRONT 

‚úÖ SANITIZA√áAO NO BACK END - service completamente protegido

‚úÖ Privilege Escalation - Valida√ß√£o de admin por UUID(id1b4e28ba-2fa1-11d2-883f-0016d3cca427) // no script do banco mesmo

‚úÖ SENHA HASH - seguran√ßa em senhas





cd "C:\Users\rodrigo\Downloads\PROJETO CHAMADO TI\back"
php -S localhost:8001 index.php
live server


& "C:\Program Files\MySQL\MySQL Server 8.0\bin\mysql.exe" -u userAdm -p
userAdm
secsistemas37666451829369Rr@





CONTROLLER FICA COM JSON




--HASH DE SENHAS(NO FIM VC NUNCA VE A SENHA REAL DO USER E O LOGIN COMPARA MAGICAMENTE O TEXT COM HASH)
cria√ßao de hasH √© feita no service no metodo create/update/login, no database a senha deve suportar varios caracteries

CREATE:
$senhaHash = password_hash(trim($userData['senha_user']), PASSWORD_DEFAULT);
    $user = new Users([
        'nome' => $userData['nome_user'],
        'telefone' => $userData['telefone_user'],
        'senha' => $senhaHash, // ‚úÖ Agora √© HASH
        'setor' => $userData['setor_user']
    ]);

UPDATE:
if (!empty($data['senha_user'])) {
   $data['senha_hash'] = password_hash(trim($data['senha_user']), PASSWORD_DEFAULT);
   unset($data['senha_user']); // Remove a senha plain text
 }

login:
O password_verify() faz TUDO
php
$senhaTextDoFront = "minhaSenha123";
$hashDoBanco = "$2y$10$9sT8Jx7K6hF5dE2rC4vM3e...";

$resultado = password_verify($senhaTextDoFront, $hashDoBanco);
// ‚úÖ Retorna TRUE se bater, FALSE se n√£o bater





----------SANITIZA√áAO

public function getMyUser($myId) // nome, senha e n√∫mero
{
    try {
        // üßº Sanitiza√ß√£o do ID recebido
        $myId = trim(strip_tags($myId));

        // üîç Valida√ß√£o de UUID
        if (empty($myId) || !preg_match('/^[0-9a-fA-F-]{36}$/', $myId)) {
            return [
                'success' => false,
                'data' => [],
                'total' => 0,
                'message' => 'ID de usu√°rio inv√°lido'
            ];
        }

        // üì¶ Busca os dados do usu√°rio
        $user = $this->repositoryUsuarios->filtroUserId($myId);

        // üö´ Remove dados sens√≠veis
        unset($user['id'], $user['setor'], $user['senha_user']);

        // üîí Sanitiza texto para evitar XSS no front
        if (is_array($user)) {
            foreach ($user as $key => $value) {
                if (is_string($value)) {
                    // Evita inje√ß√µes HTML/JS refletidas
                    $user[$key] = htmlspecialchars(trim($value), ENT_QUOTES, 'UTF-8');
                }
            }
        }

        // üì§ Retorno padronizado
        return [
            'success' => true,
            'data' => $user,
            'total' => is_array($user) ? count($user) : 0,
            'message' => 'Usu√°rio carregado com sucesso'
        ];
    } catch (Exception $e) {
        error_log("Erro ao buscar o User: " . $e->getMessage());
        return [
            'success' => false,
            'data' => [],
            'total' => 0,
            'message' => 'Erro ao carregar usu√°rio'
        ];
    }
}


--------------ESCAPE NO FRONT EVITA XSS
ISSO JA EVITA XSS, a responsabilidade prim√°ria do XSS √© do front-end, n√£o do backend
O atacante coloca algo malicioso (ex.: <script>...</script>) no banco ou na URL.
O backend retorna esse texto como parte da resposta (JSON ou HTML).
Se o front inserir esse texto no DOM como HTML, o navegador vai interpretar e executar ‚Äî XSS.
Se o front escapar (ou usar APIs que n√£o interpretam HTML), o navegador mostra s√≥ texto com os s√≠mbolos < > transformados em &lt; &gt; ‚Äî nada √© executado.
Exemplos pr√°ticos (JS)

Perigoso ‚Äî executa XSS:
// resposta.data.nome = "<script>alert(1)</script>"
document.getElementById('nome').innerHTML = resposta.data.nome; // RUIM

Seguro ‚Äî n√£o executa (insere texto puro):
document.getElementById('nome').textContent = resposta.data.nome; // BOM

Seguro usando escape manual:
function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
el.innerHTML = escapeHtml(resposta.data.nome); // agora √© seguro


üß© Quando voc√™ envia algo pro front-end
Nem todo retorno pro front √© perigoso.
Depende do tipo de dado e como ele √© usado no front.
üü¢ 1. Quando o back-end s√≥ retorna mensagens ou flags
Exemplo:
return [
  'success' => true,
  'message' => 'User atualizado com sucesso',
];
üëâ Isso √© 100% seguro ‚Äî n√£o precisa de htmlspecialchars().
Por qu√™?
Voc√™ n√£o est√° enviando dados vindos de outro usu√°rio;
Essa mensagem √© fixa, controlada pelo seu c√≥digo.
üí° Esse √© o caso do seu updateUserPopUp, deleteUser, createUser etc.
‚Üí Nenhum deles precisa de htmlspecialchars().
üü° 2. Quando o back-end retorna dados vindos do banco ou de outro usu√°rio
Exemplo:
return [
  'success' => true,
  'data' => [
    'nome' => $user['nome'],
    'telefone' => $user['telefone'],
  ],
];









--vamos criar um id diferente como se fosse uma chave numerica, quase impossivel de chutar o id admin ate acertar
CREATE TABLE usuarios (
    id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    senha VARCHAR(255) NOT NULL,
    tipo ENUM('admin','user') DEFAULT 'user'
);
--1b4e28ba-2fa1-11d2-883f-0016d3cca427
(cuidado com a fun√ßao admin que retorna os ids dos usuarios)






Front-end faz o fetch()- front esse que pode qualquer coisa q manda uma requisi√ßao pra esse fecth
‚Üí Executa o fetch() para chamar a API.
‚Üí Sempre envia junto os dados do usu√°rio (como token, id e tipo).

Controller
‚Üí Valida se a requisi√ß√£o cont√©m todos os dados obrigat√≥rios, tanto da API quanto do usu√°rio.
‚Üí Se faltar algo, a requisi√ß√£o √© rejeitada imediatamente.

Service
‚Üí Valida o n√≠vel de acesso do usu√°rio com base nos dados recebidos (ex: apenas administradores podem executar certas a√ß√µes).
‚Üí S√≥ continua o fluxo se o usu√°rio tiver permiss√£o.

Repository
‚Üí Executa apenas a parte de acesso ao banco (SQL).
‚Üí N√£o se preocupa com quem fez a requisi√ß√£o nem com permiss√µes ‚Äî recebe dados prontos e confi√°veis.


Sempre quando executa um fecth pra alguma api de admin, os dados do usuario tambem sao enviados 
e √© validado no controler se todos os dados estao sendo enviados(da api e do user) se nao funciona 
e no service eu valido o nivel de usuario dentro desses dados


 
             ‚öôÔ∏è Quando FAZ SENTIDO usar biblioteca - vendor
üßæ 1. Evitar reinventar a roda
Tem coisas que s√£o chatas, longas e j√° est√£o prontas ‚Äî tipo:
Enviar e-mail com autentica√ß√£o e HTML ‚Üí PHPMailer
Criar PDF bonito ‚Üí Dompdf
Trabalhar com planilhas Excel ‚Üí PhpSpreadsheet
Login com token JWT ‚Üí Firebase JWT
üí° Exemplo:
Gerar um PDF de nota fiscal com PHP puro √© um inferno (tabelas, margens, fontes, etc).
Com Dompdf, s√£o 5 linhas:
use Dompdf\Dompdf;
$dompdf = new Dompdf();
$dompdf->loadHtml('<h1>Nota Fiscal</h1><p>Cliente: Rodrigo</p>');
$dompdf->render();
$dompdf->stream('nota.pdf');

üõ°Ô∏è 2. Seguran√ßa e padroniza√ß√£o
Alguns recursos s√£o muito sens√≠veis, tipo:
Autentica√ß√£o (tokens, criptografia, hash de senha)
Conex√µes com APIs externas
Uploads e manipula√ß√£o de arquivos
Essas tarefas t√™m muitos detalhes t√©cnicos, e as bibliotecas s√£o testadas por milhares de pessoas, ent√£o usar uma pronta evita falhas de seguran√ßa.

üß† 3. Trabalhar com coisas externas
Se voc√™ precisa:
Integrar com API do Google, PagSeguro, Mercado Pago, AWS, etc
‚Üí essas empresas fornecem bibliotecas oficiais para facilitar a integra√ß√£o.
Exemplo:
composer require mercadopago/dx-php
Assim, em vez de montar as requisi√ß√µes e headers na unha, voc√™ usa m√©todos prontos tipo:
$payment = new MercadoPago\Payment();
$payment->amount = 100;
$payment->save();



vendor/
√â a PASTA que cont√©m as depend√™ncias.
Ela √© automaticamente gerada e gerenciada pelo Composer (ferramenta de gest√£o de pacotes PHP).
Cada subpasta aqui representa uma "biblioteca externa" instalada no projeto (como frameworks, ferramentas de email, valida√ß√£o, etc.) que seu sistema utiliza para n√£o precisar reinventar a roda.
















 Toda a p√°gina vai ter uma constante chamada ‚Äúan√¥nima‚Äù. 
 Em cada lugar que precisar do usu√°rio, h√° um verificador de permiss√£o que compara com o que est√° no localStorage. 
 Se n√£o houver nada no localStorage, mant√©m o usu√°rio como an√¥nimo. 
 Se houver algum dado no localStorage, considera que o usu√°rio j√° est√° logado e usa essas informa√ß√µes.
  
 
 
 
 
 
 as rotas e tipos de usuario estao intimamente ligados, usario tipo cliente e funcionario devem ter rotas diferentes/valida√ßoes diferentes
sempre cirar rotas pra tipos de usario diferentes e ocultar o nivel de acesso pelo back end
 No login, autentique o usu√°rio e guarde sess√£o / token no servidor.
Ao servir p√°ginas ou APIs:
N√£o inclua usuario.tipo no JSON retornado.
Em vez disso, gere e envie permiss√µes expl√≠citas (ex.: ["ver_produtos","comprar","ver_vendas"]) OU gere o markup (HTML) j√° filtrado conforme permiss√£o.
Em cada rota protegida (API ou p√°gina), verifique a permiss√£o no servidor antes de entregar dados/a√ß√£o.
O cliente recebe apenas o m√≠nimo necess√°rio. Mesmo que algu√©m veja as respostas, n√£o ter√° o "n√≠vel" bruto nem poder√° executar a√ß√µes sem token/sess√£o v√°lida.

session_start();
if (!isset($_SESSION['usuario']) || !isset($_SESSION['usuario']['id'])) {
  header('Location: /login.html');
  exit;
}
// transforma role em permiss√µes
function getPermissionsForRole($role) {
  $map = [
    'admin' => ['produtos','cdf','vendas','cdc'],
    'gerente' => ['produtos','cdf','vendas','cdc'],
    'vendedor' => ['produtos','vendas','cdc'],
    'estagiario' => ['produtos','cdc']
  ];
  return $map[$role] ?? [];
}

Quando o usu√°rio faz login com sucesso, o back-end gera um token JWT (ou outro tipo de token).
Esse token √© armazenado no front (por exemplo, no localStorage), e toda vez que o front faz uma requisi√ß√£o protegida, ele envia esse token no cabe√ßalho HTTP:
Front-end (JavaScript)
const token = localStorage.getItem('token');
const response = await fetch('http://localhost:8001/api/produtos', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  }
});

Mesmo que algu√©m altere o tipo de usu√°rio no localStorage ou tente liberar menus de administrador, isso n√£o d√° permiss√£o real se o servidor verificar as autoriza√ß√µes corretamente.
Por isso, o back-end deve validar o token de autentica√ß√£o (como um JWT) em cada requisi√ß√£o e garantir que apenas usu√°rios com o n√≠vel de acesso correto (admin, gerente, etc.) 
executem certas a√ß√µes.
Exemplo (em PHP):
$token = getallheaders()['Authorization'] ?? '';
$user = TokenService::decode($token);
if (!$user || $user['tipo'] !== 'admin') {
    http_response_code(403);
    echo json_encode(['erro' => 'Acesso negado']);
    exit;
}
// c√≥digo protegido para admins
echo json_encode(['sucesso' => 'Acesso autorizado']);




 starta o servidor php no caminho do index php, verifica caminho da api dentro do role inteiro
cd "C:\Users\rodrigo\Downloads\PROJETO-TENIS.STORE"
php -S localhost:8001 index.php


produtos.html
'http://localhost:8001/api';
${API_BASE_URL}/produtos`);
    Ou
          const response = await fetch('http://localhost:8001/api/produtos', {


index.php
// --- Instancia routes
$router = new routes();
$router->handle($method, $path, $query_string);
?>


routes.php
$this->routes['GET']['/api/produtos'] =  
function() { $controller = new ProductController(); return $controller->index();};


ProductController.php
public function index() {
return $this->productService->getAllProducts();}


ProductService.php
    // üì¶ Servi√ßo para buscar TODOS os produtos
    public function getAllProducts() {
        try {
            $produtos = $this->productRepository->findAll();
            
            return [
                'success' => true,
                'data' => $produtos,
                'total' => count($produtos),
                'message' => 'Produtos carregados com sucesso'
            ];
            
        } catch (Exception $e) {
            error_log("Erro ao buscar todos os produtos: " . $e->getMessage());
            return [
                'success' => false,
                'data' => [],
                'total' => 0,
                'message' => 'Erro ao carregar produtos'
            ];
        }
    }
        


repository.php
   // üì¶ Buscar TODOS os produtos
    public function findAll() {
        $results = $this->db->select('Produtos'); // ‚Üê Note o nome da tabela "Produtos"
        
        $products = [];
        foreach ($results as $data) {
            $products[] = new Product($data);
        }
        return $products;
    }
    
    // üîç Buscar produto por ID
    public function findById($id_produto) {
        $results = $this->db->select('Produtos', ['id_produto' => $id_produto], 1);
        
        if (!empty($results)) {
            return new Product($results[0]);
        }
        return null;
    }




database.php
    private $pdo;
    // Credenciais MySQL
    private $host = 'localhost';
    private $dbname = 'loja_tenis';
    private $username = 'userAdm';
    private $password = 'secsistemas37666451829369Rr@';
public function __construct() {
    try {
        $this->pdo = new PDO(
            "mysql:host={$this->host};dbname={$this->dbname};charset=utf8",
            // ‚Üë String de conex√£o (DSN)
            
            $this->username,  // ‚Üê Credencial 1
            $this->password,  // ‚Üê Credencial 2
            
            [  // ‚Üê Configura√ß√µes extras do PDO
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                // ‚Üë Faz o PDO lan√ßar exce√ß√µes em erros
                
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
                // ‚Üë Retorna resultados como array associativo
            ]
        );
    } catch (PDOException $e) {
        die("Erro MySQL: " . $e->getMessage());
        // ‚Üë Para a aplica√ß√£o se houver erro de conex√£o
    }
}
  public function select($table, $conditions = [], $limit = null) {
    $sql = "SELECT * FROM $table";
    $params = [];
    
    if (!empty($conditions)) {
        $where = [];
        foreach ($conditions as $key => $value) {
            $where[] = "$key = :$key";        // ‚Üê "id = :id"
            $params[":$key"] = $value;        // ‚Üê [":id" => 1]
        }
        $sql .= " WHERE " . implode(' AND ', $where);
        // ‚Üë "SELECT * FROM users WHERE id = :id AND status = :status"
    }
    
    if ($limit) {
        $sql .= " LIMIT $limit";  // ‚Üê " LIMIT 10"
    }
    
    $stmt = $this->pdo->prepare($sql);
    $stmt->execute($params);      // ‚Üê Substitui :id por 1, etc.
    return $stmt->fetchAll();     // ‚Üê Retorna todos os resultados
}





 
 
 
 
 
 
 
 
 
 public/
‚îÇ
‚îú‚îÄ‚îÄ index.php      # entrada principal
‚îú‚îÄ‚îÄ home.html      # p√°ginas est√°ticas
‚îú‚îÄ‚îÄ contato.html
‚îú‚îÄ‚îÄ css/
‚îú‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ img/










√ìTIMO! O servidor est√° aceitando conex√µes sem erros PHP! Isso √© um grande progresso.


Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> curl http://localhost:8001/api/produtos


StatusCode        : 200
StatusDescription : OK
Content           : Erro MySQL: SQLSTATE[HY000] [1045] Access denied for user 'userAdmin'@'localhost' (using
                    password: YES)
RawContent        : HTTP/1.1 200 OK
                    Host: localhost:8001
                    Connection: close
                    Access-Control-Allow-Origin: *
                    Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
                    Access-Control-Allow-Headers: Content-Type
                    Con...
Forms             : {}
Headers           : {[Host, localhost:8001], [Connection, close], [Access-Control-Allow-Origin, *],
                    [Access-Control-Allow-Methods, GET, POST, PUT, DELETE, OPTIONS]...}
Images            : {}
InputFields       : {}
Links             : {}
ParsedHtml        : mshtml.HTMLDocumentClass
RawContentLength  : 103


Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> cd "C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends"
PS C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends> php -S localhost:8001 index.php
[Sun Oct 26 23:44:30 2025] PHP 8.4.14 Development Server (http://localhost:8001) started
[Sun Oct 26 23:44:36 2025] [::1]:11096 Accepted
[Sun Oct 26 23:44:36 2025] [::1]:11096 Closing





cd "C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends"

php -S localhost:8001 index.php

curl http://localhost:8001/api/produtos //teste do caminho da api no fecth


"C:\php\php.ini"
extension_dir = "C:\php\ext"
extension=pdo_mysql
extension=mysqli


# Testar MySQL
php -m | findstr "mysql"

# Testar cURL
php -m | findstr "curl"

# Testar GD
php -m | findstr "gd"

# Testar JSON
php -m | findstr "json"


O Windows PowerShell
Copyright (C) Microsoft Corporation. Todos os direitos reservados.

Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> curl http://localhost:8001/api/produtos


StatusCode        : 200
StatusDescription : OK
Content           : {
                        "success": true,
                        "data": [
                            {},
                            {},
                            {},
                            {},
                            {},
                            {},
                            {},
                            {}
                        ],
                        "total": 8,
                        "message": "Produtos carregados com suces...
RawContent        : HTTP/1.1 200 OK
                    Host: localhost:8001
                    Connection: close
                    Access-Control-Allow-Origin: *
                    Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
                    Access-Control-Allow-Headers: Content-Type
                    Con...
Forms             : {}
Headers           : {[Host, localhost:8001], [Connection, close], [Access-Control-Allow-Origin, *],
                    [Access-Control-Allow-Methods, GET, POST, PUT, DELETE, OPTIONS]...}
Images            : {}
InputFields       : {}
Links             : {}
ParsedHtml        : mshtml.HTMLDocumentClass
RawContentLength  : 205



PS C:\Users\rodri>










O servidor PHP built-in √© apenas tempor√°rio - para quando voc√™ executa o comando.
Servidor Tempor√°rio:
cmd
php -S localhost:8000
Voc√™ precisa iniciar o servidor PHP NA MESMA PASTA onde est√° seu arquivo .php
Nao pode fecahr cmd se nao apara de rodar o servidor


"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends\app\core\testDatabase.php"
"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\"
http://localhost:8000/testDatabase.php
<?php
$host = 'localhost';
$dbname = 'loja_tenis';
$username = 'userAdminBig';
$password = 'secsistemas37666451829369Rr@';

try {
    $pdo = new PDO("mysql:host=$host;dbname=$dbname", $username, $password);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    echo "Conex√£o bem-sucedida!";
} catch (PDOException $e) {
    echo "Erro: " . $e->getMessage();
}
?>  



php -S localhost:8001 index.php
curl http://localhost:8001/api/produtos







"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE"
cd C:\Users\rodri\Downloads
php -S localhost:8000
http://localhost:8000/phptest.php

php
<?php
echo "PHP funcionando! Vers√£o: " . PHP_VERSION;
phpinfo();
?>





# Todos os produtos
curl http://localhost/loja_tenis/produtos

# Produto espec√≠fico
curl http://localhost/loja_tenis/produtos/1

# Buscar por nome
curl "http://localhost/loja_tenis/produtos/buscar?nome=tenis"

# Estat√≠sticas
curl http://localhost/loja_tenis/produtos/estatisticas





// Buscar todos os produtos
fetch('http://localhost/loja_tenis/produtos')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            data.data.forEach(produto => {
                console.log(produto.getNomeProduto());
            });
        }
    });

// Buscar produto espec√≠fico
fetch('http://localhost/loja_tenis/produtos/15')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Produto:', data.data);
        }
    });







                    --FLUXO--


// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Root (roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
    return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real






                    --TIPOS DE USUARIO--

‚ÄúUsu√°rio master‚Äù, ‚Äúusu√°rio cliente‚Äù, ‚Äúusu√°rio funcion√°rio‚Äù...
Esses n√£o s√£o sistemas diferentes, s√£o n√≠veis de acesso diferentes dentro do mesmo sistema.

Como isso funciona na pr√°tica:

Voc√™ tem uma tabela de usu√°rios s√≥, por exemplo:

id	nome	        email	    senha_hash	tipo
1	Jo√£o Silva	joao@email.com   (hash)	    master
2	Ana Souza	ana@email.com    (hash)	    funcionario
3	Pedro Lima	pedro@email.com  (hash)	    cliente

O campo tipo (ou role) define o ‚Äún√≠vel‚Äù do usu√°rio.
Assim, quando ele faz login, o backend sabe se ele √© master, funcionario ou cliente.

‚öôÔ∏è Como aplicar isso:
No login, voc√™ valida o usu√°rio normalmente.
Depois, dependendo do tipo, voc√™ mostra ou esconde partes do sistema.
Exemplo:
master ‚Üí pode acessar tudo.
funcionario ‚Üí pode gerenciar produtos, mas n√£o excluir usu√°rios.
cliente ‚Üí s√≥ v√™ produtos e faz pedidos.



üí° Implementa√ß√£o simples:

No front-end, voc√™ pode usar algo assim:

if (user.tipo === 'master') {
  mostrarBotaoAdmin();
} else if (user.tipo === 'funcionario') {
  mostrarPainelFuncionario();
} else {
  mostrarTelaCliente();
}

No back-end, voc√™ tamb√©m pode validar rotas:

if ($user['tipo'] !== 'master') {
  return ['success' => false, 'message' => 'Acesso negado'];
}






üö¶ Fluxo b√°sico de login:

Front-end envia o email e senha via fetch():
fetch('/backend/public/index.php?action=login', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({email: 'joao@email.com', senha: '123456'})
})
.then(r => r.json())
.then(console.log);


Controller recebe isso e chama o Service:
class UserController {
  private $service;
  public function __construct() { $this->service = new UserService(); }

  public function login($data) {
    return $this->service->login($data['email'], $data['senha']);
  }
}


Service valida os dados e consulta o Repository:
class UserService {
  private $repo;
  public function __construct() { $this->repo = new UserRepository(); }

  public function login($email, $senha) {
    $user = $this->repo->findByEmail($email);
    if (!$user) return ['success' => false, 'message' => 'Usu√°rio n√£o encontrado'];

    if (password_verify($senha, $user['senha_hash'])) {
      return ['success' => true, 'user' => $user];
    } else {
      return ['success' => false, 'message' => 'Senha incorreta'];
    }
  }
}


Repository busca o usu√°rio no banco (ou JSON):
class UserRepository {
  private $db;
  public function __construct() { $this->db = Database::getInstance(); }

  public function findByEmail($email) {
    $data = $this->db->getData();
    foreach ($data['users'] as $u) {
      if ($u['email'] === $email) return $u;
    }
    return null;
  }
}


üîí Resultado:
Se o login for v√°lido ‚Üí o back retorna o usu√°rio e o tipo (ex: master).
O front-end guarda isso (ex: no localStorage) e redireciona pra tela certa.







DEBUG NO F12 E SERVIDOR PHP


starta o servidor php no caminho do index php, verifica caminho da api dentro do role inteiro e inicia o live server

cd "C:\Users\rodrigo\Downloads\PROJETO-TENIS.STORE\backs-ends"
php -S localhost:8001 index.php

basta voc√™ mudar os caminhos dos endpoints no fetch para os que existem no seu backend e pronto
O editar, excluir e cadastrar s√£o as opera√ß√µes CRUD b√°sicas: cadastrar cria novos produtos, editar modifica os existentes e excluir remove produtos do sistema - voc√™ s√≥ precisa conectar cada um ao endpoint correto da sua API.

//as rotas e tipos de usuario estao intimamente ligados, usario tipo cliente e funcionario devem ter rotas diferentes/valida√ßoes diferentes













------------------------------------------------------------------------------------------------------------------












                                                                                   8-----PHP GENERAL-----8


PHP √© uma linguagem de servidor, focada em desenvolvimento web back-end.
Ela roda no servidor e √© usada para gerar  processar formul√°rios, conectar com bancos de dados, e controlar l√≥gicas de neg√≥cio em sistemas web.
Qualquer fonte de segurna√ßa por se tratar de um desenvlvimenteo sem frameworks tera que ser feita manualmente por exemplo: a valida√ßao ($request->validate()), sendo feita no controller por exemplo, outras maneiras envolvem o proprio front ou uma pasta separada e com referencias no controller


Voc√™ pode criar:
 Sistemas administrativos (CRUD) - create - read - update - delete
 Pain√©is de controle e portais
 APIs REST para apps mobile/web
 Lojas virtuais (ex: WooCommerce)
 Blogs e CMSs (ex: WordPress)
 Softwares SaaS simples


1. Sistemas Administrativos (CRUD)
S√£o a espinha dorsal da maioria dos aplicativos web. Permitem que administradores gerenciem o conte√∫do e os dados de um site ou aplica√ß√£o de forma f√°cil e visual.
O que s√£o: Qualquer sistema que permita Criar, Ler (Read), Atualizar (Update) e Deletar (Delete) registros em um banco de dados.
Exemplos Pr√°ticos:
Backend de um site institucional: Gerenciar p√°ginas, blog posts, portf√≥lio, depoimentos e usu√°rios.
Sistema de gerenciamento de clientes (CRM simples): Cadastrar clientes, registrar intera√ß√µes (coment√°rios, vendas, suporte).
Controle de estoque: Adicionar produtos, atualizar quantidades, categorizar, registrar entradas e sa√≠das.

2. Pain√©is de Controle e Portais
V√£o al√©m do CRUD b√°sico, agregando informa√ß√µes, m√©tricas e funcionalidades em um √∫nico lugar.
O que s√£o: Interfaces que consolidam dados de v√°rias fontes e fornecem ferramentas espec√≠ficas para um tipo de usu√°rio.
Exemplos Pr√°ticos:
Portal do Aluno/Funcion√°rio: Notas, boletos, calend√°rio acad√™mico, materiais de aula.
Dashboard Anal√≠tico: Gr√°ficos e relat√≥rios de vendas, tr√°fego do site, desempenho de campanhas (usando bibliotecas como Chart.js).
Painel de Afiliados: Controle de comiss√µes, gera√ß√£o de links de rastreamento, relat√≥rios de performance.

3. APIs RESTful
O PHP n√£o serve apenas para gerar HTML. √â excelente para criar a camada de backend (l√≥gica de neg√≥cio) que serve dados para outros clientes.
O que s√£o: Conjuntos de endpoints (URLs) que seguem o padr√£o REST e devolvem dados estruturados, tipicamente em JSON, em vez de HTML.
Exemplos Pr√°ticos:
Backend para App Mobile: Um app iOS ou Android consome a API PHP para login, buscar produtos, realizar pedidos, etc.
API para Frontend Javascript: Um site feito com React, Vue.js ou Angular consome a API PHP para buscar dados dinamicamente sem recarregar a p√°gina (Single Page Application - SPA).
Integra√ß√£o entre Sistemas: Permitir que outros softwares (ex.: um ERP) troquem dados com o seu sistema de forma automatizada.

4. Lojas Virtuais (E-commerce)
Sistemas complexos que envolvem cat√°logo de produtos, carrinho de compras, gateway de pagamento, fluxo de checkout e gest√£o de pedidos.
O que s√£o: Plataformas completas para venda de produtos ou servi√ßos online.
Exemplos Pr√°ticos:
Lojas personalizadas: Desenvolvidas do zero para necessidades muito espec√≠ficas.
Plugins para WordPress: O WooCommerce (constru√≠do em PHP) √© um exemplo cl√°ssico que transforma um site WordPress em uma loja virtual poderosa.
Plataformas como Magento e PrestaShop: S√£o sistemas de e-commerce robustos escritos em PHP.

5. Blogs e Sistemas de Gerenciamento de Conte√∫do (CMS)
Foi uma das primeiras e mais populares aplica√ß√µes do PHP. Permitem que usu√°rios n√£o-t√©cnicos publiquem e gerenciem conte√∫do.
O que s√£o: Sistemas que separam o conte√∫do (texto, imagens) da apresenta√ß√£o (design, tema).
Exemplos Pr√°ticos:
WordPress: O CMS mais popular do mundo √© constru√≠do em PHP. Ele alimenta desde blogs simples at√© sites corporativos complexos.
Joomla e Drupal: Outras alternativas poderosas e flex√≠veis de CMS.
CMS Customizado: Desenvolver um CMS sob medida para um tipo espec√≠fico de conte√∫do (ex.: um CMS apenas para gerenciar card√°pios de restaurantes).

6. Softwares como Servi√ßo (SaaS)
Aplicativos web que oferecem uma funcionalidade espec√≠fica atrav√©s de uma assinatura, sem necessidade de instala√ß√£o local.
O que s√£o: Sistemas multi-usu√°rio onde cada cliente tem seu espa√ßo isolado (tenant) dentro da mesma aplica√ß√£o.
Exemplos Pr√°ticos:
Sistema de Gest√£o de Projetos: Similar ao Trello ou Asana, mas customizado.
Plataforma de Email Marketing: Para cria√ß√£o de listas, campanhas e relat√≥rios.
Ferramenta de Agendamento Online: Onde clientes marcam hor√°rios com profissionais.

7. Outros Sistemas Especializados
F√≥runs e Comunidades: Sistemas como o phpBB e XenForo permitem discuss√µes e intera√ß√£o entre usu√°rios.
Sistemas de Arquivos na Nuvem: Vers√µes simplificadas do Dropbox ou Google Drive para uma empresa.
Aplica√ß√µes em Tempo Real: Com o uso de bibliotecas como Ratchet ou integra√ß√£o com servi√ßos como Socket.io, o PHP pode ser usado para criar chats online, notifica√ß√µes em tempo real e dashboards que atualizam live.





                     -TECNOLOGIAS-

1. Frameworks
Frameworks fornecem uma estrutura organizada, bibliotecas e ferramentas para desenvolver aplica√ß√µes mais r√°pido, seguro e seguindo boas pr√°ticas (como MVC).
Laravel: O framework mais popular. √â elegante, expressivo e cheio de recursos. Ideal para quase todos os tipos de projeto, de APIs a sistemas completos.
Itens que inclui: ORM (Eloquent), sistema de rotas poderoso, sistema de templates (Blade), migra√ß√µes de banco de dados, autentica√ß√£o pronta.
Symfony: Um framework muito robusto e modular, often usado para projetos enterprise complexos. Muitos outros frameworks (incluindo Laravel) usam componentes dele.
CodeIgniter: Framework leve e de configura√ß√£o simples. Bom para come√ßar ou para projetos menores onde a performance crua √© um foco.
Slim: Um micro-framework. Perfeito para criar APIs RESTful e servi√ßos web pequenos e focados. Fornece o m√≠nimo de estrutura para funcionar.

2. Gerenciadores de Pacotes e Depend√™ncias
Composer: ESSENCIAL no desenvolvimento PHP moderno. √â um gerenciador de depend√™ncias. Ele permite que voc√™ instale e gerencie bibliotecas externas (chamadas de "pacotes") no seu projeto.
Exemplo: composer require laravel/framework para instalar o Laravel.

3. Bancos de Dados e ORMs
Bancos de Dados Relacionais: MySQL, PostgreSQL, SQLite. O PHP tem extens√µes nativas (como PDO e mysqli) para se conectar a eles de forma segura.
PDO (PHP Data Objects): Uma extens√£o para acessar bancos de dados de forma abstrata. Isso significa que voc√™ escreve o mesmo c√≥digo para conectar em diferentes bancos (MySQL, PostgreSQL, etc.), trocando apenas a string de conex√£o. Previne ataques de SQL Injection se usado corretamente.
ORM (Mapeamento Objeto-Relacional): Transforma tabelas do banco de dados em classes e objetos PHP, permitindo que voc√™ manipule os dados usando c√≥digo PHP instead de escrever SQL manualmente.
Eloquent (Laravel): O ORM mais famoso. Extremamente intuitivo.
Exemplo: $user = User::find(1); busca o usu√°rio com ID 1.

4. Ferramentas para APIs
OpenAPI (Swagger): Ferramenta para documentar APIs de forma padronizada. Voc√™ escreve um arquivo (YAML/JSON) que descreve todos os endpoints, par√¢metros e respostas, e ele gera uma documenta√ß√£o interativa e bonita.
API Platform: Um framework poderoso constru√≠do sobre Symfony para criar APIs RESTful e GraphQL de forma extremamente r√°pida, com muitas funcionalidades prontas (serializa√ß√£o, pagina√ß√£o, filtros, valida√ß√£o).

5. Ferramentas de Teste
PHPUnit: O framework padr√£o para escrever testes unit√°rios e de integra√ß√£o. Voc√™ escreve c√≥digo para testar seu pr√≥prio c√≥digo, garantindo que cada parte (unidade) funcione corretamente e que quebras futuras sejam detectadas.
Pest: Uma alternativa moderna ao PHPUnit, com uma sintaxe mais limpa e leg√≠vel, focada em simplicidade.

6. Ferramentas de Qualidade de C√≥digo
PHPStan e Psalm: Analisadores est√°ticos. Eles analisam seu c√≥digo sem execut√°-lo para encontrar bugs, erros de tipo e poss√≠veis problemas. Elevam a qualidade e confiabilidade do c√≥digo a outro n√≠vel.
PHP_CodeSniffer: Verifica se seu c√≥digo segue um padr√£o de estilo definido (ex.: PSR-12), mantendo a consist√™ncia em toda a base de c√≥digo.

7. Ferramentas de Deployment e Containers
Docker: Permite empacotar sua aplica√ß√£o PHP com todos os seus depend√™ncias (servidor web, banco de dados, vers√£o espec√≠fica do PHP) em um "container". Garante que a aplica√ß√£o funcione de forma id√™ntica em qualquer ambiente (desenvolvimento, produ√ß√£o).
Packer, Ansible, Terraform: Ferramentas para automatizar a cria√ß√£o de servidores e a implanta√ß√£o da aplica√ß√£o em ambientes de produ√ß√£o (ex.: AWS, DigitalOcean).

8. Cache e Performance
OPcache: Extens√£o do PHP que armazena o bytecode compilado dos scripts em mem√≥ria. Elimina a necessidade de recompilar o script a cada request, dando um boost enorme de performance. J√° vem ativada na maioria dos ambientes.
Redis / Memcached: Sistemas de armazenamento de dados em mem√≥ria (chave-valor). Usados para cache de queries de banco, sessions, resultados de APIs e qualquer dado que precise ser acessado muito r√°pido.

9. Filas e Processamento Ass√≠ncrono
Redis + Laravel Queues / Symfony Messenger: Permite colocar tarefas demoradas (ex.: enviar email, processar imagem, gerar relat√≥rio) em uma fila para serem processadas em background por workers. Isso torna a resposta ao usu√°rio muito mais r√°pida.

10. Apache
Apache HTTP Server √© um servidor web livre e de c√≥digo aberto, o mais tradicional e amplamente utilizado no ecossistema PHP. √â conhecido por sua confiabilidade e robustez.
Servir p√°ginas web (HTML, CSS, JS)
Processar requisi√ß√µes PHP atrav√©s do m√≥dulo PHP
Hospedar aplica√ß√µes web completas
Gerenciar virtual hosts (m√∫ltiplos sites num mesmo servidor)
Implementar regras de seguran√ßa via .htaccess

11. Artisan Serve
Artisan Serve √© um comando do Laravel que inicia um servidor de desenvolvimento embutido no PHP, permitindo testar aplica√ß√µes localmente sem precisar configurar um servidor web completo como Apache ou Nginx.






--------------------------------------------------------------------------------------------------------------------------------------------------------------------






                                       --FRAMEWORK LARAVEL--


Laravel √© um framework PHP moderno e robusto que fornece uma estrutura organizada para o desenvolvimento de aplica√ß√µes web. 
Ele foi criado para tornar o desenvolvimento em PHP mais r√°pido, seguro, elegante e organizado, seguindo os princ√≠pios da programa√ß√£o moderna, como MVC (Model-View-Controller), inje√ß√£o de depend√™ncia, e outros.

1. O que laravel serve (ou php artisan serve) faz:
Ele inicia um servidor web PHP embutido (o mesmo que voc√™ usaria com php -S localhost:8000) na pasta public/ do seu projeto Laravel.
Endere√ßo padr√£o: http://localhost:8000
Fun√ß√£o: Roteia todas as requisi√ß√µes para o index.php na pasta public, que √© o front controller do Laravel. A partir da√≠, o framework toma conta, interpreta as rotas, chama os controllers, etc.

2. Como ele se relaciona com APIs RESTful?
O artisan serve n√£o √© um servidor de API. Ele √© apenas o mecanismo que exp√µe sua aplica√ß√£o, que pode ou n√£o ser uma API.
Se voc√™ definir rotas de API no arquivo routes/api.php, o servidor embutido estar√° pronto para receber e responder requisi√ß√µes HTTP (GET, POST, PUT, DELETE) para esses endpoints.
Ele processar√° os controllers, retornar√° JSON (ou qualquer outro formato que voc√™ definir) e se comportar√° exatamente como uma API RESTful.
Exemplo Pr√°tico:
Voc√™ cria um endpoint em routes/api.php:
Route::get('/posts', [PostController::class, 'index']);
Voc√™ inicia o servidor:
php artisan serve
Agora, voc√™ pode acessar sua API de duas formas:
Via navegador: http://localhost:8000/api/posts
Via ferramenta como Postman/Insomnia: Enviando uma requisi√ß√£o GET para http://localhost:8000/api/posts
O servidor embutido receber√° a requisi√ß√£o, o Laravel ir√° rote√°-la para o m√©todo index do PostController, que provavelmente retornar√° um JSON, e o servidor entregar√° essa resposta.

3. O que o laravel serve N√ÉO √© / Limita√ß√µes:
√â crucial entender que este servidor √© apenas para desenvolvimento e possui limita√ß√µes s√©rias:
Desempenho: √â monothread (single-threaded). Ele processa uma requisi√ß√£o por vez. Se ele estiver ocupado processando uma requisi√ß√£o longa, todos os outros usu√°rios (ou requisi√ß√µes) ficar√£o na fila esperando. √â totalmente inadequado para produ√ß√£o.
Funcionalidades: √â um servidor muito simples, sem otimiza√ß√µes de seguran√ßa, compress√£o, cache ou configura√ß√µes avan√ßadas como um servidor web dedicado (Nginx, Apache).
Acesso Externo: Por padr√£o, ele s√≥ responde para localhost. Para testar em outros dispositivos na mesma rede (ex: celular), voc√™ precisa usar php artisan serve --host=0.0.0.0.

4. No Laravel:
Quando voc√™ usa o comando:
php artisan make:controller UsuarioController --resource
Ele j√° cria automaticamente os m√©todos para fazer um CRUD:
index() ‚Üí listar usu√°rios (Read)
create() ‚Üí mostrar formul√°rio de cria√ß√£o (Create)
store() ‚Üí salvar novo usu√°rio (Create)
edit() ‚Üí mostrar formul√°rio de edi√ß√£o (Update)
update() ‚Üí salvar altera√ß√µes (Update)
destroy() ‚Üí deletar usu√°rio (Delete)
show() ‚Üí (opcional) mostrar um √∫nico usu√°rio (Read)






--------------------------------------------------------------------------------------------------------------------------------------------------------------------







                                                                    8---ASSUNTOS DO PHP---8




üß© O que √© o Composer
O Composer √© o gerenciador de depend√™ncias do PHP.
üëâ Ele n√£o √© uma pasta ‚Äî √© um programa (um execut√°vel .phar) que voc√™ instala na sua m√°quina.
Ele serve pra:
baixar bibliotecas de terceiros, gerar a pasta vendor/ com os c√≥digos dessas libs, e gerenciar vers√µes (atualizar, remover, etc).
üíª Ent√£o sim: voc√™ precisa instalar o Composer na sua m√°quina
Se quiser usar bibliotecas externas, voc√™ instala ele uma vez.
Depois, no terminal do seu projeto, voc√™ usa comandos tipo:
composer require dompdf/dompdf
Isso vai criar:
meu_projeto/
‚îú‚îÄ‚îÄ vendor/
‚îÇ   ‚îú‚îÄ‚îÄ autoload.php
‚îÇ   ‚îî‚îÄ‚îÄ dompdf/
‚îú‚îÄ‚îÄ composer.json
‚îî‚îÄ‚îÄ composer.lock



                       -CRIANDO ARQUIVO INDEX.PHP PARA ROTEAMENTO DE ENDPOINTS PARA SEUS RESPECTIVIOS METODOS NO CONTROLLER(PHP VANILLA)-


Request (Requisi√ß√£o): √â o que chega no servidor. S√£o os dados de entrada.
Response (Resposta): √â o que sai do servidor. S√£o os dados de sa√≠da (normalmente em JSON, HTML, etc.).
A Rota (Route) √© a ponte que conecta o M√©todo HTTP (do fetch) com o M√©todo do Controller (que processar√° a request).


---CONFIGURA√áAO:
Na pr√°tica, isso quase sempre acontece em um arquivo central √∫nico (como o index.php na pasta p√∫blica). Esse arquivo vira o "front controller" da sua aplica√ß√£o.

Capturar a solicita√ß√£o:
$url = $_SERVER['REQUEST_URI']; // Pega a URL acessada (ex: /api/usuarios/42)
$metodo = $_SERVER['REQUEST_METHOD']; // Pega o verbo HTTP (GET, POST, PUT, DELETE)

Interpretar a solicita√ß√£o (Ser o "carteiro"):
Voc√™ usa estruturas de decis√£o (if, switch, match) ou express√µes regulares (preg_match) para comparar a $url e o $metodo com os padr√µes que voc√™ definiu.

Chamar a fun√ß√£o correta (Entregar a encomenda):
Se encontrar uma correspond√™ncia, voc√™ chama a fun√ß√£o ou inclui o arquivo respons√°vel.

Exemplo  Simples do index.php:

<?php

require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../config/routes.php';

header("Content-Type: application/json; charset=UTF-8");
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type, Authorization");

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}
//Quando o navegador faz requisi√ß√£o entre dom√≠nios, primeiro manda OPTIONS para perguntar: "Posso acessar?"
//Respondemos "200 OK" ‚Üí "Sim, pode!"
//O navegador ent√£o envia a requisi√ß√£o REAL (POST, GET, etc.)


$requestMethod = $_SERVER['REQUEST_METHOD']; // EX: 'POST'
$requestUri = $_SERVER['REQUEST_URI'];

//M√©todo HTTP: POST, GET, PUT, DELETE
//Caminho da URL: /api/users, /api/products, etc.
//SERVIDOR = PR√âDIO COM V√ÅRIAS PORTAS
//üìç PORTA 1: /api/users       ‚Üí Sala dos usu√°rios
//üìç PORTA 2: /api/products    ‚Üí Sala dos produtos  
//üìç PORTA 3: /api/orders      ‚Üí Sala dos pedidos
//CLIENTE: "Oi, quero entrar na SALA DOS USU√ÅRIOS!"
//RECEPCIONISTA (Router): "Ah, ent√£o use a PORTA /api/users"


$router = new Router();
$router->handleRequest($requestMethod, $requestUri);

//DENTRO DO handleRequest():
//$requestMethod = 'POST';     // ‚Üê M√âTODO
//$requestUri = '/api/users';  // ‚Üê CAMINHO
//Router procura: "Existe rota POST para /api/users?"
//Se existir: chama UserController::create()
//Se n√£o: retorna 404


?>


Teoricamente, o index.php atua como o front controller ou ponto √∫nico de entrada da aplica√ß√£o, 
seguindo o padr√£o de design Front Controller, onde todas as requisi√ß√µes HTTP s√£o centralizadas e ent√£o delegadas a um componente roteador. 
Sua fun√ß√£o primordial n√£o √© processar a l√≥gica de neg√≥cio ou decidir qual a√ß√£o tomar, mas sim capturar os dados brutos da requisi√ß√£o (m√©todo e URI) e repass√°-los ao roteador, 
que √© o componente especializado em examinar esses dados, compar√°-los com uma tabela de rotas predefinida e, finalmente, invocar o controlador e m√©todo espec√≠ficos 
correspondentes ao endpoint solicitado. Essa separa√ß√£o de concerns garante que o index.php mantenha uma responsabilidade √∫nica e desacoplada, promovendo uma arquitetura mais organizada 
e escal√°vel.







----





                       -EXEMPLO DE COMUNICA√áAO DE FRONT E BACK EM PHP VANILLA-


‚öôÔ∏è EXEMPLO DE BACK END COM ‚Äì PHP Puro (sem framework)
 Cadastro de usu√°rio (formul√°rio + salvando no banco)
Quando no HTML voc√™ coloca <form action="cadastro.php" method="POST">, o navegador faz uma requisi√ß√£o HTTP para esse caminho (relativo ou absoluto) ‚Äî
e o servidor precisa ter um arquivo chamado cadastro.php (ou uma rota que resolva esse caminho) para receber essa requisi√ß√£o.


 form.html:
<form action="cadastro.php" method="POST">
  Nome: <input type="text" name="nome"><br>
  Email: <input type="email" name="email"><br>
  <button type="submit">Cadastrar</button>
</form>



 cadastro.php:
<?php
$nome = $_POST['nome'] ?? '';
$email = $_POST['email'] ?? '';
if (empty($nome) || empty($email)) {
    die("Preencha todos os campos.");
}
$conn = new mysqli('localhost', 'root', '', 'meubanco');
if ($conn->connect_error) {
    die("Erro na conex√£o: " . $conn->connect_error);
}
$stmt = $conn->prepare("INSERT INTO usuarios (nome, email) VALUES (?, ?)");
$stmt->bind_param("ss", $nome, $email);
// Usando prepared statement (seguro contra SQL Injection)
//?? (dois pontos de interroga√ß√£o) √© o operador null coalescing: significa ‚Äúse $_POST['nome'] existir e n√£o for null, usa; sen√£o usa '' (string vazia)‚Äù.
if ($stmt->execute()) {
    echo "Usu√°rio cadastrado com sucesso!";
} else {
    echo "Erro ao cadastrar: " . $stmt->error;
}
$stmt->close();
$conn->close();



EXEMPLO RELATIVO EM RELA√áAO AO LOCAL DO ENDPOINT SEM O USO DO INDEX.PHP COM ROUTE:
<form action="../../BackEnd/php/cadastro.php" method="POST">
  Nome: <input type="text" name="nome"><br>
  Email: <input type="email" name="email"><br>
  <button type="submit">Cadastrar</button>
</form>


EXEMPLO USANDO O INDEX PARA ROTEAR:
A ideia √©:
Voc√™ deixa todos os requests passarem pelo index.php.
O form aponta para index.php, e voc√™ cria uma regra para direcionar cada a√ß√£o ao PHP certo.
Exemplo:
<form action="index.php" method="POST">
  <input type="hidden" name="acao" value="cadastro">
  Nome: <input type="text" name="nome"><br>
  Email: <input type="email" name="email"><br>
  <button type="submit">Cadastrar</button>
</form>






----





                       -EXEMPLO DE COMUNICA√áAO DE BACK E BC EM PHP VANILLA-



üìò Teoria
Basicamente todo tutorial de conex√£o entre backend e banco de dados √© feito por c√≥digo.
O Back-End se conecta diretamente ao Banco de Dados usando drivers ou bibliotecas espec√≠ficas.
Essa conex√£o pode ser local (localhost) ou remota (servidor).
N√ÉO se usa uma API para conectar ao banco. O acesso √© direto via c√≥digo.
Local (na sua m√°quina):
Voc√™ conecta usando localhost ou 127.0.0.1 (se o banco est√° rodando no seu PC).
Hospedagem (servidor/host):
Voc√™ conecta usando o IP p√∫blico ou hostname do servidor onde o banco est√° rodando (ex.: meubanco.mysql.umbler.com).


Requisitos para conex√£o:
Host/IP ‚Üí localhost ou seuservidor.com
Porta ‚Üí padr√£o (MySQL = 3306, Postgres = 5432, Mongo = 27017, etc.)
Usu√°rio ‚Üí ex.: root, admin, meu_usuario
Senha ‚Üí senha do usu√°rio
Nome do banco ‚Üí ex.: db_loja, db_faculdade


Banco hospedado?
Use host do servi√ßo (ex: meubanco.mysql.umbler.com).
Garanta que a hospedagem permita conex√µes remotas.
Caso contr√°rio, suba o Back-End no mesmo servidor do banco.


‚ö™‚ö™‚ö™EXEMPLO DE CONEXAO
<?php
// Dados da conex√£o
$host = 'localhost'; // ou IP do servidor
$db = 'meu_banco';
$user = 'root';
$password = 'minhasenha';
// Conectando ao banco
$conn = new mysqli($host, $user, $password, $db);
// Verificando se houve erro
if ($conn->connect_error) {
    die("Erro ao conectar: " . $conn->connect_error);
}
echo "Conectado ao banco com sucesso!";
$conn->close(); // Fechar a conex√£o 
?>


‚òÅÔ∏è Quer conectar a um banco remoto?
S√≥ altere isso:
$host = '123.123.123.123'; // IP do servidor com o banco
Ou, se for um dom√≠nio:
$host = 'db.servidor.com';



Seguran√ßa dos Dados (Valida√ß√£o e Saneamento)
Nunca confie nos dados que v√™m do frontend. Sempre valide e saneie todas as entradas antes de process√°-las ou armazen√°-las no banco de dados.

Valida√ß√£o: Garante que os dados est√£o no formato e tipo esperados (ex: um e-mail √© realmente um e-mail, uma idade √© um n√∫mero).

Saneamento: Remove ou escapa caracteres perigosos que podem ser usados em ataques como SQL Injection ou Cross-Site Scripting (XSS).

3. Exemplo Pr√°tico de Backend (PHP Vanilla)
Vamos criar um exemplo simples onde o frontend envia dados de um formul√°rio e o backend os processa de forma segura.

Estrutura de Arquivos:

/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ backend/
    ‚îî‚îÄ‚îÄ api.php
frontend/index.html

HTML

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formul√°rio Seguro</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        form div { margin-bottom: 10px; }
        label { display: inline-block; width: 80px; }
        input[type="text"], input[type="email"] { width: 200px; padding: 5px; }
        button { padding: 10px 15px; }
        #response { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; }
    </style>
</head>
<body>
    <h1>Enviar Dados com Seguran√ßa</h1>

    <form id="dataForm">
        <div>
            <label for="nome">Nome:</label>
            <input type="text" id="nome" name="nome" required>
        </div>
        <div>
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit">Enviar</button>
    </form>

    <div id="response"></div>

    <script>
        document.getElementById('dataForm').addEventListener('submit', async function(event) {
            event.preventDefault(); // Impede o envio padr√£o do formul√°rio

            const nome = document.getElementById('nome').value;
            const email = document.getElementById('email').value;

            const formData = new FormData();
            formData.append('nome', nome);
            formData.append('email', email);

            try {
                // IMPORTANT: Use HTTPS para a URL do backend em produ√ß√£o!
                const response = await fetch('http://localhost/backend/api.php', { // Mude para HTTPS e seu dom√≠nio!
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                document.getElementById('response').innerText = JSON.stringify(data, null, 2);

            } catch (error) {
                console.error('Erro ao enviar dados:', error);
                document.getElementById('response').innerText = 'Erro ao enviar dados.';
            }
        });
    </script>
</body>
</html>


backend/api.php

<?php
header('Content-Type: application/json'); // Informa que a resposta ser√° JSON

// Permite requisi√ß√µes de origens espec√≠ficas (CORS)
// Em produ√ß√£o, substitua '*' pelo dom√≠nio do seu frontend (ex: 'https://seufrotend.com')
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Se for uma requisi√ß√£o OPTIONS (pr√©-voo CORS), apenas responda e saia
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit(0);
}

$response = [];

// 1. Valida√ß√£o do M√©todo da Requisi√ß√£o
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405); // M√©todo N√£o Permitido
    $response = ['status' => 'error', 'message' => 'M√©todo n√£o permitido.'];
    echo json_encode($response);
    exit();
}

// 2. Coleta e Valida√ß√£o de Dados
$nome = $_POST['nome'] ?? '';
$email = $_POST['email'] ?? '';

$errors = [];

// Valida√ß√£o do nome
if (empty($nome)) {
    $errors[] = 'O nome √© obrigat√≥rio.';
} elseif (strlen($nome) < 3) {
    $errors[] = 'O nome deve ter pelo menos 3 caracteres.';
}

// Valida√ß√£o do email
if (empty($email)) {
    $errors[] = 'O email √© obrigat√≥rio.';
} elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    $errors[] = 'Formato de email inv√°lido.';
}

// Se houver erros de valida√ß√£o, retorna-os
if (!empty($errors)) {
    http_response_code(400); // Requisi√ß√£o Inv√°lida
    $response = ['status' => 'error', 'message' => 'Erros de valida√ß√£o', 'errors' => $errors];
    echo json_encode($response);
    exit();
}

// 3. Saneamento dos Dados (Ap√≥s a valida√ß√£o, para garantir que n√£o h√° caracteres perigosos)
// Para o nome, podemos remover tags HTML e codificar caracteres especiais
$nomeSaneado = htmlspecialchars(strip_tags($nome), ENT_QUOTES, 'UTF-8');

// Para o email, filter_var com FILTER_SANITIZE_EMAIL j√° faz um bom trabalho, mas podemos refor√ßar
$emailSaneado = filter_var($email, FILTER_SANITIZE_EMAIL);
// Se voc√™ for armazenar em banco de dados, usaria fun√ß√µes de escape como mysqli_real_escape_string() ou PDO.

// 4. Processamento de Dados (Ex: salvar no banco de dados)
// Neste exemplo, apenas retornamos os dados processados.
// Em um cen√°rio real, voc√™ faria:
// - Conex√£o segura ao banco de dados (usando PDO, por exemplo)
// - Preparar e executar statements SQL para evitar SQL Injection
// - Tratamento de erros de banco de dados

// Simula√ß√£o de sucesso
$response = [
    'status' => 'success',
    'message' => 'Dados recebidos e processados com sucesso!',
    'data' => [
        'nome_saneado' => $nomeSaneado,
        'email_saneado' => $emailSaneado,
        'timestamp' => date('Y-m-d H:i:s')
    ]
];

http_response_code(200); // OK
echo json_encode($response);

?>



 Intera√ß√£o com Banco de Dados (Adi√ß√£o Segura com PDO)
Expandindo o exemplo anterior, vamos simular o salvamento dos dados em um banco de dados MySQL.

Pr√©-requisitos:

Um servidor MySQL em execu√ß√£o.

Um banco de dados (ex: meusistema).

Uma tabela (ex: usuarios) com colunas para nome e email.

SQL

CREATE DATABASE IF NOT EXISTS meusistema;
USE meusistema;
CREATE TABLE IF NOT EXISTS usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
Agora, vamos modificar o arquivo backend/api.php para incluir a conex√£o e inser√ß√£o no banco de dados.

backend/api.php (Vers√£o Atualizada com Banco de Dados)

PHP

<?php
header('Content-Type: application/json'); // Informa que a resposta ser√° JSON

// Permite requisi√ß√µes de origens espec√≠ficas (CORS)
// Em produ√ß√£o, substitua '*' pelo dom√≠nio do seu frontend (ex: 'https://seufrotend.com')
header('Access-Control-Allow-Origin: *'); 
header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Se for uma requisi√ß√£o OPTIONS (pr√©-voo CORS), apenas responda e saia
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit(0);
}

$response = [];

// 1. Valida√ß√£o do M√©todo da Requisi√ß√£o
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405); // M√©todo N√£o Permitido
    $response = ['status' => 'error', 'message' => 'M√©todo n√£o permitido.'];
    echo json_encode($response);
    exit();
}

// 2. Coleta e Valida√ß√£o de Dados
$nome = $_POST['nome'] ?? '';
$email = $_POST['email'] ?? '';

$errors = [];

// Valida√ß√£o do nome
if (empty($nome)) {
    $errors[] = 'O nome √© obrigat√≥rio.';
} elseif (strlen($nome) < 3) {
    $errors[] = 'O nome deve ter pelo menos 3 caracteres.';
}

// Valida√ß√£o do email
if (empty($email)) {
    $errors[] = 'O email √© obrigat√≥rio.';
} elseif (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    $errors[] = 'Formato de email inv√°lido.';
}

// Se houver erros de valida√ß√£o, retorna-os
if (!empty($errors)) {
    http_response_code(400); // Requisi√ß√£o Inv√°lida
    $response = ['status' => 'error', 'message' => 'Erros de valida√ß√£o', 'errors' => $errors];
    echo json_encode($response);
    exit();
}

// 3. Saneamento dos Dados
$nomeSaneado = htmlspecialchars(strip_tags($nome), ENT_QUOTES, 'UTF-8');
$emailSaneado = filter_var($email, FILTER_SANITIZE_EMAIL);

// --- IN√çCIO DA PARTE DO BANCO DE DADOS ---

// Configura√ß√µes do Banco de Dados
$dbHost = 'localhost';
$dbName = 'meusistema'; // Altere para o nome do seu banco de dados
$dbUser = 'root';      // Altere para seu usu√°rio do banco de dados
$dbPass = '';          // Altere para sua senha do banco de dados (NUNCA em produ√ß√£o!)

A raz√£o pela qual voc√™ NUNCA deve ter a senha do banco de dados (ou qualquer credencial sens√≠vel) hardcoded diretamente no seu c√≥digo-fonte, especialmente em produ√ß√£o, √© por causa de:
Vazamento de Credenciais:
Controle de Vers√£o (Git, etc.): Se o seu c√≥digo for versionado (e ele deve ser!), a senha estar√° l√° para qualquer um que tiver acesso ao hist√≥rico do reposit√≥rio. Mesmo que voc√™ remova depois, o hist√≥rico pode permanecer.

try {
    // Conex√£o com o banco de dados usando PDO
    // O atributo ATTR_ERRMODE para ERRMODE_EXCEPTION garante que erros de SQL lancem exce√ß√µes
    $pdo = new PDO("mysql:host=$dbHost;dbname=$dbName;charset=utf8", $dbUser, $dbPass, [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, // Retorna arrays associativos por padr√£o
        PDO::ATTR_EMULATE_PREPARES => false // Desabilita a emula√ß√£o de prepared statements para seguran√ßa
    ]);

    // 4. Inser√ß√£o Segura no Banco de Dados com Prepared Statements (PDO)
    $stmt = $pdo->prepare("INSERT INTO usuarios (nome, email) VALUES (:nome, :email)");

    // Bind dos par√¢metros para evitar SQL Injection
    $stmt->bindParam(':nome', $nomeSaneado, PDO::PARAM_STR);
    $stmt->bindParam(':email', $emailSaneado, PDO::PARAM_STR);
    
    $stmt->execute(); // Executa a query

    // Se chegou at√© aqui, a inser√ß√£o foi bem-sucedida
    $response = [
        'status' => 'success',
        'message' => 'Usu√°rio cadastrado com sucesso!',
        'data' => [
            'id' => $pdo->lastI
9nsertId(), // Retorna o ID do √∫ltimo registro inserido
            'nome_salvo' => $nomeSaneado,
            'email_salvo' => $emailSaneado,
            'timestamp_backend' => date('Y-m-d H:i:s')
        ]
    ];
    http_response_code(201); // 201 Created para sucesso na cria√ß√£o de recurso

} catch (PDOException $e) {
    // Tratamento de erros de banco de dados
    if ($e->getCode() === '23000') { // C√≥digo de erro para viola√ß√£o de UNIQUE KEY (email duplicado)
        http_response_code(409); // Conflito
        $response = ['status' => 'error', 'message' => 'O email informado j√° est√° cadastrado.', 'debug_info' => $e->getMessage()];
    } else {
        http_response_code(500); // Erro Interno do Servidor
        // Em produ√ß√£o, n√£o mostre $e->getMessage() diretamente ao usu√°rio!
        // Apenas registre o erro internamente e mostre uma mensagem gen√©rica.
        error_log("Erro de PDO: " . $e->getMessage()); // Registra o erro no log do servidor
        $response = ['status' => 'error', 'message' => 'Ocorreu um erro interno ao processar sua requisi√ß√£o.', 'debug_info' => $e->getMessage()];
    }
}

echo json_encode($response);
exit();

?> 

√ìtima pergunta! A senha n√£o vai mais diretamente no seu c√≥digo PHP, mas sim no ambiente onde o seu c√≥digo PHP ser√° executado.

Vamos detalhar as duas principais formas:

Op√ß√£o 1: Vari√°veis de Ambiente (A mais recomendada para produ√ß√£o)
Se voc√™ usar vari√°veis de ambiente, a senha ser√° configurada no sistema operacional ou no ambiente de execu√ß√£o do servidor.

Onde voc√™ colocaria a senha, dependendo do seu setup:

Servidor Apache/Nginx (com PHP-FPM):
Voc√™ pode configurar vari√°veis de ambiente no arquivo de configura√ß√£o do seu virtual host ou no arquivo de configura√ß√£o do PHP-FPM pool.

Exemplo para Apache (.htaccess ou arquivo de configura√ß√£o do VirtualHost):

Apache

# No seu .htaccess (se permitido) ou no arquivo de config do VirtualHost
SetEnv DB_PASSWORD "sua_senha_real_aqui"
Exemplo para Nginx (no bloco server ou location):
Nginx n√£o passa vari√°veis de ambiente diretamente para PHP-FPM de forma simples. Voc√™ geralmente precisaria configur√°-las no pool do PHP-FPM.

Exemplo para PHP-FPM (.pool.conf):
Em /etc/php/8.x/fpm/pool.d/www.conf (ou similar):

Ini, TOML

env[DB_PASSWORD] = "sua_senha_real_aqui"
Depois de editar, reinicie o servi√ßo PHP-FPM: sudo service php8.x-fpm restart.

Servidor Web Integrado do PHP (para desenvolvimento local r√°pido):
Voc√™ pode definir vari√°veis de ambiente antes de iniciar o servidor.

Exemplo no Linux/macOS (Terminal):

Bash

DB_PASSWORD="sua_senha_dev" php -S localhost:8000
Exemplo no Windows (Prompt de Comando ou PowerShell):

DOS

set DB_PASSWORD="sua_senha_dev"
php -S localhost:8000
(Note que no Windows as vari√°veis setadas assim s√£o tempor√°rias para a sess√£o do terminal).

Ferramentas de Orquestra√ß√£o (Docker, Kubernetes):
Aqui √© onde as vari√°veis de ambiente brilham! Voc√™ as define no Dockerfile, docker-compose.yml ou nos manifestos do Kubernetes.

Exemplo docker-compose.yml:

YAML

version: '3.8'
services:
  app:
    build: .
    environment:
      DB_PASSWORD: "sua_senha_docker"
    # ... outras configura√ß√µes
Hospedagens Gerenciadas (Hostinger, HostGator, AWS Elastic Beanstalk, Heroku, Vercel, etc.):
Quase todas as plataformas de hospedagem oferecem um painel de controle ou CLI onde voc√™ pode definir vari√°veis de ambiente para sua aplica√ß√£o. Esta √© a forma mais comum e segura em produ√ß√£o.

Voc√™ vai para a se√ß√£o de configura√ß√µes da sua aplica√ß√£o e procura por "Environment Variables", "Config Vars", etc.

Op√ß√£o 2: Arquivo de Configura√ß√£o Externo e Seguro
Se voc√™ optar por um arquivo de configura√ß√£o, a senha estar√° nesse arquivo.

Onde voc√™ colocaria a senha:

No arquivo de configura√ß√£o:
Voc√™ cria um arquivo PHP (ex: config.php) que cont√©m as credenciais.

PHP

// /caminho/muito/seguro/para/config.php
<?php
return [
    'db_host' => 'localhost',
    'db_name' => 'meusistema',
    'db_user' => 'seu_usuario',
    'db_pass' => 'sua_senha_real_aqui' // A senha est√° aqui!
];
?>
Localiza√ß√£o do arquivo:

Absolutamente crucial: Este arquivo DEVE estar localizado fora da raiz do documento web (fora de public_html, www, htdocs ou qualquer pasta que seja diretamente acess√≠vel via URL no navegador).

Por exemplo, se a raiz do seu site for /var/www/html, voc√™ colocaria o config.php em /var/www/config ou /home/seu_usuario/app_config.

No seu c√≥digo PHP (no api.php), voc√™ ent√£o faria include '/caminho/muito/seguro/para/config.php'; com o caminho absoluto.

Controle de Vers√£o (.gitignore):
Adicione o nome desse arquivo (e possivelmente o diret√≥rio onde ele est√°) ao seu arquivo .gitignore (ou equivalente se usar outro sistema de controle de vers√£o). Isso garante que ele nunca ser√° enviado para o reposit√≥rio de c√≥digo.

Qual usar?
Para Produ√ß√£o: Vari√°veis de Ambiente s√£o geralmente consideradas a melhor pr√°tica moderna, especialmente em ambientes de nuvem, Docker e CI/CD, pois s√£o muito flex√≠veis e a senha nunca toca o disco em um arquivo.

Para Desenvolvimento Local ou Projetos Menores: Um arquivo de configura√ß√£o externo e bem protegido com .gitignore pode ser mais simples de configurar inicialmente.









---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










                                                                 --CYBERSEGURNA√áA EM PHP--

üîê Principais Amea√ßas e Prote√ß√µes


1. Inje√ß√£o SQL (SQL Injection)
O que √©: Ataque onde invasores inserem c√≥digo SQL malicioso em entradas de dados
Prote√ß√£o: Use consultas preparadas (prepared statements) com PDO
php
// VULNER√ÅVEL
$query = "SELECT * FROM usuarios WHERE email = '$email'";
// ‚úÖ SEGURO (com PDO)
$stmt = $pdo->prepare("SELECT * FROM usuarios WHERE email = :email");
$stmt->bindParam(':email', $email);
$stmt->execute();


2. Cross-Site Scripting (XSS)
O que √©: Inje√ß√£o de scripts maliciosos em p√°ginas web
Prote√ß√£o: Sanitize e valide TODOS os dados de entrada
// Sanitiza√ß√£o de dados
$nome = filter_input(INPUT_POST, 'nome', FILTER_SANITIZE_STRING);
$email = filter_var($_POST['email'], FILTER_SANITIZE_EMAIL);
$numero = filter_var($_POST['numero'], FILTER_SANITIZE_NUMBER_INT);


3. Cross-Site Request Forgery (CSRF)
O que √©: Ataque que for√ßa usu√°rios a executar a√ß√µes n√£o intencionais
Prote√ß√£o: Use tokens CSRF √∫nicos para cada sess√£o
// Gerar token CSRF
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
// Verificar token em formul√°rios
if ($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    die('Token CSRF inv√°lido!');
}


4. Valida√ß√£o de Dados
Regra de ouro: Nunca confie em dados enviados pelo usu√°rio
function validarUsuario($dados) {
    $erros = [];
    // Valida√ß√£o de email
    if (!filter_var($dados['email'], FILTER_VALIDATE_EMAIL)) {
        $erros[] = 'Email inv√°lido';
    }
    // Valida√ß√£o de senha forte
    if (strlen($dados['senha']) < 8 || 
        !preg_match('/[A-Z]/', $dados['senha']) || 
        !preg_match('/[0-9]/', $dados['senha'])) {
        $erros[] = 'Senha deve ter pelo menos 8 caracteres, uma letra mai√∫scula e um n√∫mero';
    }
    return $erros;
}


5. Autentica√ß√£o Segura
Boas pr√°ticas para sistema de login:
// Hash de senha (NUNCA armazene senhas em texto puro)
$senhaHash = password_hash($senha, PASSWORD_DEFAULT);
// Verificar senha
if (password_verify($senhaDigitada, $senhaHash)) {
    // Login bem-sucedido
}
// Regenerar ID de sess√£o ap√≥s login
session_regenerate_id(true);


6. Headers de Seguran√ßa
Prote√ß√£o adicional com headers HTTP:
// Headers de seguran√ßa
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('X-XSS-Protection: 1; mode=block');
header('Strict-Transport-Security: max-age=31536000; includeSubDomains');


7. Prote√ß√£o contra Uploads Maliciosos
Valida√ß√£o de arquivos enviados:
$arquivo = $_FILES['arquivo'];
$extensao = strtolower(pathinfo($arquivo['name'], PATHINFO_EXTENSION));
$extensoesPermitidas = ['jpg', 'jpeg', 'png', 'gif', 'pdf'];
// Validar tipo e extens√£o
if (!in_array($extensao, $extensoesPermitidas) || 
    !getimagesize($arquivo['tmp_name'])) {
    die('Tipo de arquivo n√£o permitido!');
}
// Renomear arquivo para evitar path traversal
$novoNome = uniqid() . '.' . $extensao;
move_uploaded_file($arquivo['tmp_name'], 'uploads/' . $novoNome);

8. Rate Limiting (Prote√ß√£o contra Bruteforce)
Limitar tentativas de login:
session_start();
if (!isset($_SESSION['tentativas_login'])) {
    $_SESSION['tentativas_login'] = 0;
    $_SESSION['ultima_tentativa'] = time();
}
// Verificar se excedeu o limite
if ($_SESSION['tentativas_login'] > 5 && 
    time() - $_SESSION['ultima_tentativa'] < 300) {
    die('Muitas tentativas. Tente novamente em 5 minutos.');
}


9. Logs e Monitoramento
Registrar atividades importantes:
function registrarLog($mensagem, $usuario = 'Sistema') {
    $data = date('Y-m-d H:i:s');
    $ip = $_SERVER['REMOTE_ADDR'];
    $log = "[$data] [$ip] [$usuario] $mensagem" . PHP_EOL;
    
    file_put_contents('logs/seguranca.log', $log, FILE_APPEND | LOCK_EX);
}
// Exemplo de uso
registrarLog('Tentativa de login falhou', $email);


10. Configura√ß√µes Seguras do PHP
php.ini seguro:
ini
; Configura√ß√µes importantes
expose_php = Off
display_errors = Off
log_errors = On
allow_url_fopen = Off
allow_url_include = Off
session.cookie_httponly = 1
session.cookie_secure = 1


                           


                                    -SEGURAN√áA COM PHP VANILLA-


Valida√ß√£o ($request->validate())
CSRF autom√°tico
Middleware (ex: auth)
PDO

1. VALIDA√á√ÉO ($request->validate())
Onde fica? Dentro do m√©todo do seu controller.
A valida√ß√£o √© uma das primeiras coisas que voc√™ faz no m√©todo, assim que recebe a requisi√ß√£o ($request).
Exemplo Pr√°tico no Controller:
// 1. DECLARA√á√ÉO DO M√âTODO
// O m√©todo 'store' √© chamado quando algu√©m acessa a rota POST /posts
// Ele recebe um objeto 'Request' que cont√©m TODOS os dados do formul√°rio
public function store(Request $request)
{
    // 2. VALIDA√á√ÉO DOS DADOS
    // Aqui √© a m√°gica. A gente PEDE para o Laravel validar a $request
    $dadosValidados = $request->validate([
        // Regra para o campo 'title': 
        // - 'required': N√ÉO pode estar vazio.
        // - 'string': Deve ser um texto.
        // - 'max:255': Tem no m√°ximo 255 caracteres.
        'title' => 'required|string|max:255',

        // Regra para o campo 'body':
        // - 'required': N√ÉO pode estar vazio.
        // - 'string': Deve ser um texto.
        'body' => 'required|string',
    ]);

    // 3. SE O C√ìDIGO CHEGOU AT√â AQUI, SIGNIFICA QUE A VALIDA√á√ÉO PASSOU!
    // Os dados foram "peneirados" e est√£o limpos e seguros.
    // $dadosValidados cont√©m APENAS os campos que foram validados (title e body).

    // 4. USO DOS DADOS V√ÅLIDOS
    // Cria um novo registro no banco de dados usando os dados validados.
    $post = Post::create($dadosValidados);

    // 5. RESPOSTA
    // Redireciona o usu√°rio para a p√°gina do post que ele acabou de criar.
    return redirect('/posts/' . $post->id);
}


2. MIDDLEWARE (ex: auth)
Onde fica? Fora do m√©todo, geralmente na defini√ß√£o do controller ou na rota.
O middleware √© um "filtro" que a requisi√ß√£o passa ANTES de chegar ao m√©todo do controller. Voc√™ n√£o coloca a l√≥gica do middleware dentro do m√©todo, voc√™ aplica o middleware ao controller ou rota.

Aplicando no Construtor do Controller:
(O c√≥digo fica no topo do controller)
// App\Http\Controllers\PostController.php
class PostController extends Controller
{
    public function __construct(){
        // Aplica o middleware 'auth' a TODOS os m√©todos deste controller
        $this->middleware('auth');

        // Ou aplica apenas a m√©todos espec√≠ficos:
        $this->middleware('auth')->only(['create', 'store', 'edit', 'update', 'destroy']);
        
        // Ou aplica a todos EXCETO alguns:
        $this->middleware('auth')->except(['index', 'show']);
    }

    // ... outros m√©todos ...
}


3. PROTE√á√ÉO CSRF (@csrf)
Onde fica? No formul√°rio HTML (arquivo Blade), N√ÉO no controller.
O token CSRF √© enviado pelo front-end (como um campo de formul√°rio hidden) e verificado automaticamente por um middleware global do Laravel. Voc√™ n√£o escreve nenhum c√≥digo de verifica√ß√£o no controller. √â autom√°tico.
Exemplo no Formul√°rio (View Blade):
html
<!-- resources/views/posts/create.blade.php -->
<form method="POST" action="/posts">
    @csrf <!-- ISSO GERA O TOKEN NO FORMUL√ÅRIO -->
    
    <input type="text" name="title">
    <textarea name="body"></textarea>
    <button type="submit">Criar Post</button>
</form>
O middleware VerifyCsrfToken (j√° registrado no n√∫cleo do Laravel) checa automaticamente se o token desse formul√°rio √© v√°lido. Se n√£o for, ele bloqueia a requisi√ß√£o antes mesmo de chegar no controller.



4. PROTE√á√ÉO CONTRA SQL INJECTION (PDO)
Onde fica? No c√≥digo PHP que faz consultas ao banco de dados ‚Äî geralmente dentro do controller ou camada de servi√ßo (service/repository).
A prote√ß√£o acontece ao usar prepared statements com valores vinculados (bind), evitando que dados maliciosos se misturem com o comando SQL.
Voc√™ n√£o precisa escapar os dados manualmente, nem fazer valida√ß√µes espec√≠ficas para proteger contra injection ‚Äî o PDO faz isso automaticamente ao separar dados da query.

Exemplo com PDO (Seguro):
// Conex√£o (exemplo simples)
$pdo = new PDO('mysql:host=localhost;dbname=meubanco', 'root', 'senha');
// Dados recebidos do front-end
$email = $_POST['email'];
// Consulta segura com prepared statement
$stmt = $pdo->prepare("SELECT * FROM usuarios WHERE email = :email");
$stmt->bindParam(':email', $email);
$stmt->execute();
$usuario = $stmt->fetch(PDO::FETCH_ASSOC);

Exemplo inseguro (N√ÉO usar):
$email = $_POST['email'];
$sql = "SELECT * FROM usuarios WHERE email = '$email'";
$resultado = $pdo->query($sql); // Vulner√°vel a SQL Injection!










                                  -SEGURAN√áA COM LARAVEL-


Valida√ß√£o ($request->validate())
CSRF autom√°tico
Middleware (ex: auth)


1. Valida√ß√£o ($request->validate())
O que √©?
Uma maneira incrivelmente simples e poderosa de validar os dados que chegam do usu√°rio (por exemplo, de um formul√°rio), garantindo que eles seguem as regras que voc√™ definir (como ser um e-mail v√°lido, ter um n√∫mero m√≠nimo de caracteres, etc.).
Como funciona?
Voc√™ chama este m√©todo dentro do seu Controller, passando um array de regras.
Exemplo:
public function store(Request $request){
    // Valida os dados da requisi√ß√£o
    $dadosValidados = $request->validate([
        'title' => 'required|string|max:255',
        'body' => 'required|string',
        'email' => 'required|email|unique:users,email'
    ]);
    // Se chegou aqui, os dados s√£o v√°lidos!
    // $dadosValidados cont√©m apenas os dados que foram validados.
    Post::create($dadosValidados);

    return redirect('/posts');
}
O que acontece se falhar?
Se a valida√ß√£o falhar, o Laravel automaticamente redireciona o usu√°rio de volta para a p√°gina anterior (o formul√°rio) e popula a vari√°vel $errors na view, para voc√™ exibir as mensagens de erro.
Benef√≠cio: Escreve-se muito menos c√≥digo e a l√≥gica fica extremamente leg√≠vel.

2. CSRF Autom√°tico
O que √©?
CSRF (Cross-Site Request Forgery) √© um tipo de ataque onde um site malicioso engana o navegador de um usu√°rio logado para executar uma a√ß√£o indesejada em outro site (ex: mudar seu e-mail no Gmail). O Laravel protege voc√™ disso automaticamente.
Como funciona?
O Laravel gera um "token" (uma chave secreta √∫nica) para cada sess√£o de usu√°rio. Todo formul√°rio HTML que faz uma requisi√ß√£o POST, PUT, PATCH ou DELETE precisa incluir esse token.
Voc√™ faz isso usando a diretiva @csrf no Blade:
<form method="POST" action="/profile">
    @csrf <!-- Isso gera um input hidden com o token -->
    <input type="text" name="name">
    <button type="submit">Enviar</button>
</form>
O que acontece?
O Laravel, ao receber a requisi√ß√£o, verifica automaticamente se o token enviado √© v√°lido. Se n√£o for, ele bloqueia a requisi√ß√£o.
Benef√≠cio: Seguran√ßa robusta contra um tipo de ataque muito comum, sem voc√™ quase precisar pensar nisso.


3. Middleware (ex: auth)
O que √©?
Middleware s√£o como "pontos de controle" ou "filtros" que uma requisi√ß√£o HTTP passa antes de chegar √† sua rota/controller. Eles podem executar a√ß√µes antes e depois da requisi√ß√£o ser processada.
Middleware mais comum: auth
Fun√ß√£o: Verificar se o usu√°rio que est√° fazendo a requisi√ß√£o est√° autenticado (logado).
Como usar? Voc√™ "aplica" ele na rota ou no controller.
Exemplo em uma rota:
// Esta rota s√≥ √© acess√≠vel para usu√°rios logados.
// Se um usu√°rio n√£o logado tentar acessar, o middleware 'auth'
// redirecionar√° ele para a p√°gina de login.
Route::get('/profile', [ProfileController::class, 'show'])->middleware('auth');
Outros exemplos de middleware:
auth.admin: Poderia checar se o usu√°rio √© admin.
log: Registrar todas as requisi√ß√µes em um arquivo de log.
trim.strings: Limpar espa√ßos em branco de dados de entrada.
Benef√≠cio: Permite que voc√™ intercepte e manipule requisi√ß√µes de forma centralizada e reutiliz√°vel, mantendo seus controllers limpos. √â a solu√ß√£o perfeita para preocupa√ß√µes transversais como autentica√ß√£o, CORS, logging, etc.


Resumo Final
Valida√ß√£o	 Garantir que os dados de entrada est√£o corretos.	Um fiscal de qualidade checando se sua encomenda est√° certa antes de entrar no dep√≥sito.
CSRF	     Proteger contra ataques de falsifica√ß√£o de solicita√ß√£o entre sites.	Um selo de seguran√ßa em um documento importante que prova que √© aut√™ntico.
Middleware	 Filtrar e manipular requisi√ß√µes HTTP (ex: checar se o usu√°rio est√° logado).	Os postos de controle de uma festa, que verificam seu ingresso (auth) ou idade (age.check)









---------------------------------------------------------------------------------------------------------------------------------------------------------------------------







EXEMPLO 2:

// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Root (roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
        return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio e escolhe o repository
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real









                                                8---EXEMPLO PRATICO DE UM PROJETO WEB COM PHP---8
          


Quando o back-end e front-end est√£o separados, a comunica√ß√£o tem que ser via API RESTful. O back-end vira um servi√ßo de dados e o front-end vira um cliente independente que consome esses dados.
Se voc√™ quer algo simples e direto, pode fazer o front-end apenas com a pasta assets/ e o index.html. Essa √© a abordagem tradicional e v√°lida para projetos menores.
Views n√£o fazem sentido nessa arquitetura porque estar√≠amos "separando o front dentro do back", o que √© contradit√≥rio quando o objetivo √© justamente separar totalmente os dois.
N√£o somos obrigados a seguir uma estrutura fixa de constru√ßao de projetos.
A conex√£o entre o backend e o banco de dados segue uma arquitetura em camadas bem definida, onde cada parte tem responsabilidades espec√≠ficas:
O Database atua como a funda√ß√£o - √© a √∫nica camada que realmente conhece e interage diretamente com o banco de dados. Ele abstrai toda a complexidade das conex√µes, seja SQLite para desenvolvimento ou MySQL para produ√ß√£o.
Os Repositories funcionam como intermedi√°rios especializados - cada entidade do sistema (usu√°rios, produtos) tem seu repository que traduz as opera√ß√µes de neg√≥cio em comandos espec√≠ficos do banco, usando os m√©todos padronizados fornecidos pelo Database.
Os Controllers mant√™m dist√¢ncia do banco - sua fun√ß√£o √© lidar com requisi√ß√µes HTTP e respostas, delegando toda a l√≥gica de dados para camadas mais internas. Eles s√£o os "porta-vozes" do sistema, focados em comunica√ß√£o externa.
Essa separa√ß√£o cria um fluxo claro: requisi√ß√µes entram pelos controllers, passam pelos services para valida√ß√µes de neg√≥cio, s√£o convertidas em opera√ß√µes de banco pelos repositories, e finalmente executadas pelo database. O resultado √© um sistema onde mudan√ßas no banco afetam apenas o database, mudan√ßas nas queries afetam apenas os repositories, e o restante do c√≥digo permanece intacto.
Controller: recebe a requisi√ß√£o (ex.: POST /usuarios/cadastrar) e valida dados b√°sicos de entrada.
Service: cont√©m a l√≥gica de neg√≥cio ‚Üí por exemplo: verificar se o e-mail j√° existe, criptografar senha, aplicar regras de cadastro.
Repository (ou DAO): faz apenas o acesso ao banco (INSERT, SELECT, UPDATE, DELETE).

//back e front separados(api restfull e sem view) - php puro - seguran√ßa por conta propria no middleware 
meu_projeto/
‚îÇ
‚îú‚îÄ‚îÄ backend/                  # API RESTful (PHP puro COMPATIVEL COM A HOSTGATOR)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Model.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Database.php
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/      # Controladores API (retornam JSON)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Api/          # Pasta espec√≠fica para APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserController.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductController.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/           # Models (entidades de neg√≥cio)
‚îÇ   ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ User.php      # Entidade User
‚îÇ   ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ Product.php   # Entidade Product
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/         # Camada de Servi√ßos  
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/     # Padr√£o Repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/               # Configura√ß√µes
‚îÇ       ‚îî‚îÄ‚îÄ routes.php
‚îÇ   ‚îî‚îÄ‚îÄ public/
‚îÇ       ‚îî‚îÄ‚îÄ index.php         # Front Controller da API
‚îÇ
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ frontend/                 # Aplica√ß√£o Front-End (Separada)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ html/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ js/ 
‚îÇ   ‚îî‚îÄ‚îÄ ‚îî‚îÄ‚îÄ images/
‚îÇ   
‚îÇ
‚îî‚îÄ‚îÄ vendor/                   # Depend√™ncias (Composer)






Front-end faz o fetch()- front esse que pode qualquer coisa q manda uma requisi√ßao pra esse fecth
‚Üí Executa o fetch() para chamar a API.
‚Üí Sempre envia junto os dados do usu√°rio (como token, id e tipo).

Controller
‚Üí Valida se a requisi√ß√£o cont√©m todos os dados obrigat√≥rios, tanto da API quanto do usu√°rio.
‚Üí Se faltar algo, a requisi√ß√£o √© rejeitada imediatamente.

Service
‚Üí Valida o n√≠vel de acesso do usu√°rio com base nos dados recebidos (ex: apenas administradores podem executar certas a√ß√µes).
‚Üí S√≥ continua o fluxo se o usu√°rio tiver permiss√£o.

Repository
‚Üí Executa apenas a parte de acesso ao banco (SQL).
‚Üí N√£o se preocupa com quem fez a requisi√ß√£o nem com permiss√µes ‚Äî recebe dados prontos e confi√°veis.


Sempre quando executa um fecth pra alguma api de admin, os dados do usuario tambem sao enviados 
e √© validado no controler se todos os dados estao sendo enviados(da api e do user) se nao funciona 
e no service eu valido o nivel de usuario dentro desses dados




                    --FLUXO--


// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Route e Index(roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
        return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real








 
                      -RESUMO-

Basicamente a pasta core cria as classes pais(services, repositories, controllers, databases, models) e √© criado classes das entidades de negocio(User) dentro da pasta models, as duas se relacionam nas pastas(services, repositories, controllers...) por heran√ßa por parte dos pais e composi√ßao por parte dos models , assim por exemplo: 

//PASTA CONTROLLER:
//UserController.php
class UserController extends Controller { //extends √© heran√ßa
public function create() {
    // ‚úÖ RECEBE a requisi√ß√£o HTTP
    $data = $this->getRequestBody();        
    // ‚úÖ CRIA a entidade User (objeto em mem√≥ria)
    $user = new \App\Models\User();
    $user->setName($data['name'])
         ->setEmail($data['email']);
    // ‚úÖ DELEGA para o Service
    $result = $this->userService->createUser($user);
    // ‚úÖ RESPONDE para o cliente
    $this->json($result, 201);
}}
//sponsabilidade: Receber HTTP ‚Üí Criar objeto ‚Üí Delegar ‚Üí Responder JSON



--EXEMPLO MAIS ROBUSTO:

Core/Controller.php (Classe Pai)
Muita gente coloca um Controller.php gen√©rico no core/ s√≥ porque viu em frameworks grandes, mas em PHP puro, ele nem sempre faz sentido.
<?php
namespace App\Core;
abstract class Controller {
// ‚úÖ Fornece m√©todos COMUNS para TODOS os controllers
    protected function json($data, $status = 200) {
        header('Content-Type: application/json');
        http_response_code($status);
        echo json_encode($data);
        // Converte array/PHP em JSON para resposta HTTP
    }    
    protected function getRequestBody() {
        return json_decode(file_get_contents('php://input'), true);        
        // Pega dados JSON do corpo da requisi√ß√£o e converte para array PHP
    }
}


Models/User.php (Entidade de Neg√≥cio)
<?php
namespace App\Models;
class User {
    private $id;
    private $name;
    private $email;
    // Getters e Setters
    public function getId() { return $this->id; }
    public function getName() { return $this->name; }
    public function getEmail() { return $this->email; }
    public function setName($name) { $this->name = $name; return $this; }
    public function setEmail($email) { $this->email = $email; return $this; }
    // ‚úÖ Representa um USU√ÅRIO do sistema
    // ‚úÖ Armazena DADOS (propriedades)
    // ‚úÖ Fornece ACESSO aos dados (getters/setters)
}


Controllers/Api/UserController.php (RECEBE/RESPONDE)
<?php
namespace App\Controllers\Api;
use App\Core\Controller;
use App\Services\UserService;
class UserController extends Controller { 
    private $userService;
    public function __construct() {
        $this->userService = new UserService(); // COMPOSI√á√ÉO // ‚úÖ Conecta com Service
    }
    public function create() {
        $data = $this->getRequestBody();  // ‚úÖ 1. RECEBE dados da requisi√ß√£o HTTP
        $user = new \App\Models\User();  // ‚úÖ 2. CRIA objeto User com os dados
        $user->setName($data['name'])
             ->setEmail($data['email']);             
        $result = $this->userService->createUser($user);// ‚úÖ 3. PEDE para Service processar
        $this->json($result, 201);         // ‚úÖ 4. ENVIA resposta JSON
    }
    public function index() {
        $users = $this->userService->getAllUsers();
        $this->json($users);
    }
}


Services/UserService.php (COMPOSI√á√ÉO)
<?php
namespace App\Services;
use App\Models\User;
use App\Repositories\UserRepository;
class UserService {  // N√ÉO herda de Service, √© independente
    private $userRepository
    public function __construct() {
        $this->userRepository = new UserRepository(); // ‚úÖ Conecta com Repository
    }
    public function createUser(User $user) {
        // ‚úÖ 1. VALIDA regras de neg√≥cio
        if (!$user->getName() || !$user->getEmail()) {
            throw new \Exception("Dados inv√°lidos");
        }
        // ‚úÖ 2. PEDE para Repository salvar no banco
        return $this->userRepository->save($user);
    }
    
    public function getAllUsers() {
        return $this->userRepository->findAll();
    }
}


Repositories/UserRepository.php (COMPOSI√á√ÉO)
<?php
namespace App\Repositories;
use App\Models\User;
use App\Core\Database;
class UserRepository {  // N√ÉO herda de Repository
    private $db;
    public function __construct() {
        $this->db = Database::getConnection(); // ‚úÖ Conecta com banco
    }
    public function save(User $user) {
        // ‚úÖ 1. PREPARA comando SQL
        $stmt = $this->db->prepare("INSERT INTO users...");
        // ‚úÖ 2. EXECUTA no banco
        $stmt->execute([$user->getName(), $user->getEmail()]);
        // ‚úÖ 3. ATUALIZA objeto com ID gerado
        $user->setId($this->db->lastInsertId());
        return $user;
    }
    public function findAll() {
        // Busca todos os usu√°rios
        $stmt = $this->db->query("SELECT * FROM users");
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }
}
OUTRO EXEMPLO DE POSITORY
// No Repository:
class UserRepository {
    private $db;
    public function __construct() {
        // ‚úÖ Pega a conex√£o do Database
        $this->db = Database::getInstance();
    }
    public function save($user) {
        // ‚úÖ Usa os m√©todos do Database
        return $this->db->insert(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            [$user->getName(), $user->getEmail()]
        );
    }
}




                   -PASTA POR PASTA-


core/Model.php 
√â a Mae, sendo referencia pra objetos criados em outras pastas como o caso dos models, assim implemtentando regras de negocio para entidades maes e consequentemente pros filhos tbm.
√â um arquivo √∫nico que cont√©m a l√≥gica comum que todos os models v√£o ter.
core/Model.php ‚Üí Classe gen√©rica/abstrata que serve de base.
models/* (User, Product, etc.) ‚Üí S√£o filhas dessa classe base, cada uma representando uma entidade/tabela do banco.



app/services/
√â a PASTA que cont√©m os servi√ßos.
Cada arquivo aqui representa um "conjunto de regras de neg√≥cio" espec√≠fico (UserService.php, PaymentService.php).
Eles cont√™m a l√≥gica complexa do sistema (c√°lculos, valida√ß√µes, fluxos) e coordenam a intera√ß√£o entre V√°rios Models/Repositories para realizar uma opera√ß√£o completa.
Faz a l√≥gica central da aplica√ß√£o.
Cuida da sanitiza√ß√£o e seguran√ßa l√≥gica, como:
   Hash de senhas (bcrypt)
   Compara√ß√µes seguras
   Cria√ß√£o/valida√ß√£o de tokens (JWT)
   Controle de permiss√µes (roles)
Exemplo:
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import userRepository from "../repositories/userRepository.js";
const SECRET = process.env.JWT_SECRET || "chave-super-secreta"; // use vari√°vel de ambiente!
async function login(email, senha) {
  const user = await userRepository.findByEmail(email);
  if (!user) {
    const error = new Error("Usu√°rio n√£o encontrado.");
    error.status = 404;
    throw error;
  }
  const senhaCorreta = await bcrypt.compare(senha, user.senha_hash);
  if (!senhaCorreta) {
    const error = new Error("Senha incorreta.");
    error.status = 401;
    throw error;
  }
  // Gera token JWT
  const token = jwt.sign(
    { id: user.id, email: user.email },
    SECRET,
    { expiresIn: "2h" }
  );
  return token;
}
export default { login };


app/repositories/ 
√â a PASTA que cont√©m os reposit√≥rios.
Cada arquivo aqui representa um "acessante de banco de dados" espec√≠fico para uma entidade (UserRepository.php, ProductRepository.php).
Eles herdam (extends) a l√≥gica b√°sica do core/Model.php e adicionam m√©todos espec√≠ficos e complexos de consulta (findUserByActiveStatus(), getProductsWithCategories()), isolando totalmente a l√≥gica de banco do resto do sistema.
Exemplo:
import db from "../database/connection.js";
async function findByEmail(email) {
  const [rows] = await db.query("SELECT * FROM usuarios WHERE email = ?", [email]);
  return rows[0]; // retorna o primeiro usu√°rio
}
export default { findByEmail };




app/controllers/
√â a PASTA que cont√©m os controladores.
Cada arquivo aqui representa um "recebedor de requisi√ß√µes HTTP" espec√≠fico (UserController.php, AuthController.php, Autentificadordelogin.php).
Eles n√£o cont√™m regras de neg√≥cio, apenas recebem os dados da web, chamam os Services necess√°rios e devolvem a resposta (JSON, HTML, redirecionamento).
Responsabilidade principal: receber requisi√ß√µes e enviar respostas HTTP.
N√£o tem l√≥gica de neg√≥cio.
Valida dados b√°sicos (ex: campos obrigat√≥rios, formatos simples de email, etc.).
Chama o Service adequado para executar a a√ß√£o.
import authService from "../services/authService.js";
Exemplo:
export async function login(req, res) {
  try {
    const { email, senha } = req.body;
    // Valida√ß√£o b√°sica de entrada
    if (!email || !senha) {
      return res.status(400).json({ error: "Email e senha s√£o obrigat√≥rios." });
    }
    const token = await authService.login(email, senha);
    return res.status(200).json({ token });
  } catch (error) {
    console.error("Erro no login:", error);
    // Erro controlado vindo do service
    if (error.status) {
      return res.status(error.status).json({ error: error.message });
    }
    // Erro inesperado
    return res.status(500).json({ error: "Erro interno do servidor." });
  }
}



core/database.php

O arquivo que configura a conex√£o √© database.php.
Database basicamente configura os metodos e conexao, tambem camufla pro repository se conectar com ele e nao com o banco direto e utilizar os metodos presentes no database.
Configura a conex√£o (SQLite/MySQL)
Oferece m√©todos prontos (insert, select, update)  
O Database.php deve ser uma camada de abstra√ß√£o gen√©rica que funciona para QUALQUER tabela. Ele oferece m√©todos gen√©ricos que os Repositories espec√≠ficos de cada entidade v√£o usar.
"Camufla" a complexidade do banco
Trocar de banco? Muda S√ì o Database.php
Repositories? Continuam IGUAIS
Controllers/Services? Nem sabem que trocou

EXEMPLO:
import mysql from "mysql2/promise";
const db = await mysql.createPool({
  host: "localhost",
  user: "root",
  password: "senha",
  database: "minha_loja"
});
export default db;

EXEMPLO:
üìç Database.php (O Fiscal do Banco)
<?php
class Database {
    private static $instance = null;
    private $connection;
    // S√ì ELE sabe como conectar
    private function __construct() {
        // Local: SQLite
        $this->connection = new PDO('sqlite:meubanco.sqlite');
        // Produ√ß√£o: MySQL (s√≥ mudar aqui)
        // $this->connection = new PDO('mysql:host=localhost;dbname=meubanco', 'user', 'senha');
    }
    // Todos pedem conex√£o por aqui
    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new Database();
        }
        return self::$instance;
    }

    // M√©todos que todos usam
    public function insert($sql, $params) {
        $stmt = $this->connection->prepare($sql);
        $stmt->execute($params);
        return $this->connection->lastInsertId();
    }
    public function fetchAll($sql, $params = []) {
        $stmt = $this->connection->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll();
    }
}




üíæ UserRepository.php (O Usu√°rio do Banco)
<?php
class UserRepository {
    private $db;
    public function __construct() {
        // Pede conex√£o pro Database (N√ÉO conecta diretamente)
        $this->db = Database::getInstance();
    }
    public function save($user) {
        // Usa os m√©todos do Database
        return $this->db->insert(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            [$user->getName(), $user->getEmail()]
        );
    }
    public function getAll() {
        // Tamb√©m usa o Database
        return $this->db->fetchAll("SELECT * FROM users");
    }
}



app/models/ 
√â a PASTA que cont√©m os objetos.
Cada arquivo aqui representa uma entidade filha concreta do seu sistema (UserModel.php, ProductModel.php).
Eles herdam (extends) a classe base Model.php para ganhar seus m√©todos prontos.


config/
√â a PASTA que cont√©m as configura√ß√µes.
Cada arquivo aqui representa um "grupo de configura√ß√µes" espec√≠fico (database.php, security.php, routes.php).
Eles centralizam todas as configura√ß√µes ajust√°veis do sistema (conex√£o com banco, chaves de seguran√ßa, defini√ß√£o de rotas) em um √∫nico lugar, facilitando a manuten√ß√£o.


config/routes.php
√â o ARQUIVO que cont√©m o mapeamento de todas as rotas.
Ele centraliza todas as defini√ß√µes de URL do sistema (/login, /products, /user/profile) e as conecta aos controllers respons√°veis.


vendor/
√â a PASTA que cont√©m as depend√™ncias.
Ela √© automaticamente gerada e gerenciada pelo Composer (ferramenta de gest√£o de pacotes PHP).
Cada subpasta aqui representa uma "biblioteca externa" instalada no projeto (como frameworks, ferramentas de email, valida√ß√£o, etc.) que seu sistema utiliza para n√£o precisar reinventar a roda.





INDEX.HTMLExemplo de index.html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minha Loja</title>

    <!-- √çcone da aba -->
    <link rel="icon" href="frontend/images/favicon.png">

    <!-- CSS -->
    <link rel="stylesheet" href="frontend/css/style.css">

    <!-- Fontes ou bibliotecas externas -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>

    <!-- Cabe√ßalho -->
    <header>
        <h1>Minha Loja</h1>
        <nav>
            <ul>
                <li><a href="#">Home</a></li>
                <li><a href="#">Produtos</a></li>
                <li><a href="#">Contato</a></li>
            </ul>
        </nav>
    </header>

    <!-- Conte√∫do principal -->
    <main>
        <section id="produtos">
            <!-- Produtos carregados via JS -->
        </section>
    </main>

    <!-- Rodap√© -->
    <footer>
        <p>¬© 2025 Minha Loja</p>
    </footer>

    <!-- Scripts -->
    <script src="frontend/js/main.js"></script>
</body>
</html>

