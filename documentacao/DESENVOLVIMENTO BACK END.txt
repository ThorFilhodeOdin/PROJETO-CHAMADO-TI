 
‚úÖ SQL Injection - Prepared statements no Database //S√≥ o Database protege contra SQL Injection

‚úÖ CONTRA XSS NO FRONT 

‚úÖ SANITIZA√áAO NO BACK END - service completamente protegido

‚úÖ Privilege Escalation - Valida√ß√£o de admin por UUID(id1b4e28ba-2fa1-11d2-883f-0016d3cca427) // no script do banco mesmo

‚úÖ SENHA HASH - seguran√ßa em senhas







cd "C:\Users\rodrigo\Downloads\PROJETO CHAMADO TI\back"
php -S localhost:8001 index.php
live server


& "C:\Program Files\MySQL\MySQL Server 8.0\bin\mysql.exe" -u userAdm -p
userAdm
secsistemas37666451829369Rr@





CONTROLLER FICA COM JSON 





--HASH DE SENHAS(NO FIM VC NUNCA VE A SENHA REAL DO USER E O LOGIN COMPARA MAGICAMENTE O TEXT COM HASH)
cria√ßao de hasH √© feita no service no metodo create/update/login, no database a senha deve suportar varios caracteries

CREATE:
$senhaHash = password_hash(trim($userData['senha_user']), PASSWORD_DEFAULT);
    $user = new Users([
        'nome' => $userData['nome_user'],
        'telefone' => $userData['telefone_user'],
        'senha' => $senhaHash, // ‚úÖ Agora √© HASH
        'setor' => $userData['setor_user']
    ]);

UPDATE:
if (!empty($data['senha_user'])) {
   $data['senha_hash'] = password_hash(trim($data['senha_user']), PASSWORD_DEFAULT);
   unset($data['senha_user']); // Remove a senha plain text
 }

login:
O password_verify() faz TUDO
php
$senhaTextDoFront = "minhaSenha123";
$hashDoBanco = "$2y$10$9sT8Jx7K6hF5dE2rC4vM3e...";

$resultado = password_verify($senhaTextDoFront, $hashDoBanco);
// ‚úÖ Retorna TRUE se bater, FALSE se n√£o bater





----------SANITIZA√áAO

public function getMyUser($myId) // nome, senha e n√∫mero
{
    try {
        // üßº Sanitiza√ß√£o do ID recebido
        $myId = trim(strip_tags($myId));

        // üîç Valida√ß√£o de UUID
        if (empty($myId) || !preg_match('/^[0-9a-fA-F-]{36}$/', $myId)) {
            return [
                'success' => false,
                'data' => [],
                'total' => 0,
                'message' => 'ID de usu√°rio inv√°lido'
            ];
        }

        // üì¶ Busca os dados do usu√°rio
        $user = $this->repositoryUsuarios->filtroUserId($myId);

        // üö´ Remove dados sens√≠veis
        unset($user['id'], $user['setor'], $user['senha_user']);

        // üîí Sanitiza texto para evitar XSS no front
        if (is_array($user)) {
            foreach ($user as $key => $value) {
                if (is_string($value)) {
                    // Evita inje√ß√µes HTML/JS refletidas
                    $user[$key] = htmlspecialchars(trim($value), ENT_QUOTES, 'UTF-8');
                }
            }
        }

        // üì§ Retorno padronizado
        return [
            'success' => true,
            'data' => $user,
            'total' => is_array($user) ? count($user) : 0,
            'message' => 'Usu√°rio carregado com sucesso'
        ];
    } catch (Exception $e) {
        error_log("Erro ao buscar o User: " . $e->getMessage());
        return [
            'success' => false,
            'data' => [],
            'total' => 0,
            'message' => 'Erro ao carregar usu√°rio'
        ];
    }
}


--------------ESCAPE NO FRONT EVITA XSS
ISSO JA EVITA XSS, a responsabilidade prim√°ria do XSS √© do front-end, n√£o do backend
O atacante coloca algo malicioso (ex.: <script>...</script>) no banco ou na URL.
O backend retorna esse texto como parte da resposta (JSON ou HTML).
Se o front inserir esse texto no DOM como HTML, o navegador vai interpretar e executar ‚Äî XSS.
Se o front escapar (ou usar APIs que n√£o interpretam HTML), o navegador mostra s√≥ texto com os s√≠mbolos < > transformados em &lt; &gt; ‚Äî nada √© executado.
Exemplos pr√°ticos (JS)

Perigoso ‚Äî executa XSS:
// resposta.data.nome = "<script>alert(1)</script>"
document.getElementById('nome').innerHTML = resposta.data.nome; // RUIM

Seguro ‚Äî n√£o executa (insere texto puro):
document.getElementById('nome').textContent = resposta.data.nome; // BOM

Seguro usando escape manual:
function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
el.innerHTML = escapeHtml(resposta.data.nome); // agora √© seguro


üß© Quando voc√™ envia algo pro front-end
Nem todo retorno pro front √© perigoso.
Depende do tipo de dado e como ele √© usado no front.
üü¢ 1. Quando o back-end s√≥ retorna mensagens ou flags
Exemplo:
return [
  'success' => true,
  'message' => 'User atualizado com sucesso',
];
üëâ Isso √© 100% seguro ‚Äî n√£o precisa de htmlspecialchars().
Por qu√™?
Voc√™ n√£o est√° enviando dados vindos de outro usu√°rio;
Essa mensagem √© fixa, controlada pelo seu c√≥digo.
üí° Esse √© o caso do seu updateUserPopUp, deleteUser, createUser etc.
‚Üí Nenhum deles precisa de htmlspecialchars().
üü° 2. Quando o back-end retorna dados vindos do banco ou de outro usu√°rio
Exemplo:
return [
  'success' => true,
  'data' => [
    'nome' => $user['nome'],
    'telefone' => $user['telefone'],
  ],
];



















--vamos criar um id diferente como se fosse uma chave numerica, quase impossivel de chutar o id admin ate acertar
CREATE TABLE usuarios (
    id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    senha VARCHAR(255) NOT NULL,
    tipo ENUM('admin','user') DEFAULT 'user'
);
--1b4e28ba-2fa1-11d2-883f-0016d3cca427
(cuidado com a fun√ßao admin que retorna os ids dos usuarios)






Front-end faz o fetch()- front esse que pode qualquer coisa q manda uma requisi√ßao pra esse fecth
‚Üí Executa o fetch() para chamar a API.
‚Üí Sempre envia junto os dados do usu√°rio (como token, id e tipo).

Controller
‚Üí Valida se a requisi√ß√£o cont√©m todos os dados obrigat√≥rios, tanto da API quanto do usu√°rio.
‚Üí Se faltar algo, a requisi√ß√£o √© rejeitada imediatamente.

Service
‚Üí Valida o n√≠vel de acesso do usu√°rio com base nos dados recebidos (ex: apenas administradores podem executar certas a√ß√µes).
‚Üí S√≥ continua o fluxo se o usu√°rio tiver permiss√£o.

Repository
‚Üí Executa apenas a parte de acesso ao banco (SQL).
‚Üí N√£o se preocupa com quem fez a requisi√ß√£o nem com permiss√µes ‚Äî recebe dados prontos e confi√°veis.


Sempre quando executa um fecth pra alguma api de admin, os dados do usuario tambem sao enviados 
e √© validado no controler se todos os dados estao sendo enviados(da api e do user) se nao funciona 
e no service eu valido o nivel de usuario dentro desses dados












          ‚öôÔ∏è Quando FAZ SENTIDO usar biblioteca - vendor

üßæ 1. Evitar reinventar a roda
Tem coisas que s√£o chatas, longas e j√° est√£o prontas ‚Äî tipo:
Enviar e-mail com autentica√ß√£o e HTML ‚Üí PHPMailer
Criar PDF bonito ‚Üí Dompdf
Trabalhar com planilhas Excel ‚Üí PhpSpreadsheet
Login com token JWT ‚Üí Firebase JWT
üí° Exemplo:
Gerar um PDF de nota fiscal com PHP puro √© um inferno (tabelas, margens, fontes, etc).
Com Dompdf, s√£o 5 linhas:
use Dompdf\Dompdf;
$dompdf = new Dompdf();
$dompdf->loadHtml('<h1>Nota Fiscal</h1><p>Cliente: Rodrigo</p>');
$dompdf->render();
$dompdf->stream('nota.pdf');

üõ°Ô∏è 2. Seguran√ßa e padroniza√ß√£o
Alguns recursos s√£o muito sens√≠veis, tipo:
Autentica√ß√£o (tokens, criptografia, hash de senha)
Conex√µes com APIs externas
Uploads e manipula√ß√£o de arquivos
Essas tarefas t√™m muitos detalhes t√©cnicos, e as bibliotecas s√£o testadas por milhares de pessoas, ent√£o usar uma pronta evita falhas de seguran√ßa.

üß† 3. Trabalhar com coisas externas
Se voc√™ precisa:
Integrar com API do Google, PagSeguro, Mercado Pago, AWS, etc
‚Üí essas empresas fornecem bibliotecas oficiais para facilitar a integra√ß√£o.
Exemplo:
composer require mercadopago/dx-php


Assim, em vez de montar as requisi√ß√µes e headers na unha, voc√™ usa m√©todos prontos tipo:

$payment = new MercadoPago\Payment();
$payment->amount = 100;
$payment->save();














 Toda a p√°gina vai ter uma constante chamada ‚Äúan√¥nima‚Äù. 
 Em cada lugar que precisar do usu√°rio, h√° um verificador de permiss√£o que compara com o que est√° no localStorage. 
 Se n√£o houver nada no localStorage, mant√©m o usu√°rio como an√¥nimo. 
 Se houver algum dado no localStorage, considera que o usu√°rio j√° est√° logado e usa essas informa√ß√µes.
  
 
 
 


 as rotas e tipos de usuario estao intimamente ligados, usario tipo cliente e funcionario devem ter rotas diferentes/valida√ßoes diferentes
sempre cirar rotas pra tipos de usario diferentes e ocultar o nivel de acesso pelo back end
 No login, autentique o usu√°rio e guarde sess√£o / token no servidor.
Ao servir p√°ginas ou APIs:
N√£o inclua usuario.tipo no JSON retornado.
Em vez disso, gere e envie permiss√µes expl√≠citas (ex.: ["ver_produtos","comprar","ver_vendas"]) OU gere o markup (HTML) j√° filtrado conforme permiss√£o.
Em cada rota protegida (API ou p√°gina), verifique a permiss√£o no servidor antes de entregar dados/a√ß√£o.
O cliente recebe apenas o m√≠nimo necess√°rio. Mesmo que algu√©m veja as respostas, n√£o ter√° o "n√≠vel" bruto nem poder√° executar a√ß√µes sem token/sess√£o v√°lida.

session_start();
if (!isset($_SESSION['usuario']) || !isset($_SESSION['usuario']['id'])) {
  header('Location: /login.html');
  exit;
}
// transforma role em permiss√µes
function getPermissionsForRole($role) {
  $map = [
    'admin' => ['produtos','cdf','vendas','cdc'],
    'gerente' => ['produtos','cdf','vendas','cdc'],
    'vendedor' => ['produtos','vendas','cdc'],
    'estagiario' => ['produtos','cdc']
  ];
  return $map[$role] ?? [];
}

Quando o usu√°rio faz login com sucesso, o back-end gera um token JWT (ou outro tipo de token).
Esse token √© armazenado no front (por exemplo, no localStorage), e toda vez que o front faz uma requisi√ß√£o protegida, ele envia esse token no cabe√ßalho HTTP:
Front-end (JavaScript)
const token = localStorage.getItem('token');
const response = await fetch('http://localhost:8001/api/produtos', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  }
});

Mesmo que algu√©m altere o tipo de usu√°rio no localStorage ou tente liberar menus de administrador, isso n√£o d√° permiss√£o real se o servidor verificar as autoriza√ß√µes corretamente.
Por isso, o back-end deve validar o token de autentica√ß√£o (como um JWT) em cada requisi√ß√£o e garantir que apenas usu√°rios com o n√≠vel de acesso correto (admin, gerente, etc.) 
executem certas a√ß√µes.
Exemplo (em PHP):
$token = getallheaders()['Authorization'] ?? '';
$user = TokenService::decode($token);
if (!$user || $user['tipo'] !== 'admin') {
    http_response_code(403);
    echo json_encode(['erro' => 'Acesso negado']);
    exit;
}
// c√≥digo protegido para admins
echo json_encode(['sucesso' => 'Acesso autorizado']);







starta o servidor php no caminho do index php, verifica caminho da api dentro do role inteiro

cd "C:\Users\rodrigo\Downloads\PROJETO-TENIS.STORE"
php -S localhost:8001 index.php


produtos.html
'http://localhost:8001/api';
${API_BASE_URL}/produtos`);
    Ou
          const response = await fetch('http://localhost:8001/api/produtos', {


index.php
// --- Instancia routes
$router = new routes();
$router->handle($method, $path, $query_string);
?>


routes.php
$this->routes['GET']['/api/produtos'] =  
function() { $controller = new ProductController(); return $controller->index();};


ProductController.php
public function index() {
return $this->productService->getAllProducts();}


ProductService.php
    // üì¶ Servi√ßo para buscar TODOS os produtos
    public function getAllProducts() {
        try {
            $produtos = $this->productRepository->findAll();
            
            return [
                'success' => true,
                'data' => $produtos,
                'total' => count($produtos),
                'message' => 'Produtos carregados com sucesso'
            ];
            
        } catch (Exception $e) {
            error_log("Erro ao buscar todos os produtos: " . $e->getMessage());
            return [
                'success' => false,
                'data' => [],
                'total' => 0,
                'message' => 'Erro ao carregar produtos'
            ];
        }
    }
        


repository.php
   // üì¶ Buscar TODOS os produtos
    public function findAll() {
        $results = $this->db->select('Produtos'); // ‚Üê Note o nome da tabela "Produtos"
        
        $products = [];
        foreach ($results as $data) {
            $products[] = new Product($data);
        }
        return $products;
    }
    
    // üîç Buscar produto por ID
    public function findById($id_produto) {
        $results = $this->db->select('Produtos', ['id_produto' => $id_produto], 1);
        
        if (!empty($results)) {
            return new Product($results[0]);
        }
        return null;
    }




database.php
    private $pdo;
    // Credenciais MySQL
    private $host = 'localhost';
    private $dbname = 'loja_tenis';
    private $username = 'userAdm';
    private $password = 'secsistemas37666451829369Rr@';
public function __construct() {
    try {
        $this->pdo = new PDO(
            "mysql:host={$this->host};dbname={$this->dbname};charset=utf8",
            // ‚Üë String de conex√£o (DSN)
            
            $this->username,  // ‚Üê Credencial 1
            $this->password,  // ‚Üê Credencial 2
            
            [  // ‚Üê Configura√ß√µes extras do PDO
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                // ‚Üë Faz o PDO lan√ßar exce√ß√µes em erros
                
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
                // ‚Üë Retorna resultados como array associativo
            ]
        );
    } catch (PDOException $e) {
        die("Erro MySQL: " . $e->getMessage());
        // ‚Üë Para a aplica√ß√£o se houver erro de conex√£o
    }
}
  public function select($table, $conditions = [], $limit = null) {
    $sql = "SELECT * FROM $table";
    $params = [];
    
    if (!empty($conditions)) {
        $where = [];
        foreach ($conditions as $key => $value) {
            $where[] = "$key = :$key";        // ‚Üê "id = :id"
            $params[":$key"] = $value;        // ‚Üê [":id" => 1]
        }
        $sql .= " WHERE " . implode(' AND ', $where);
        // ‚Üë "SELECT * FROM users WHERE id = :id AND status = :status"
    }
    
    if ($limit) {
        $sql .= " LIMIT $limit";  // ‚Üê " LIMIT 10"
    }
    
    $stmt = $this->pdo->prepare($sql);
    $stmt->execute($params);      // ‚Üê Substitui :id por 1, etc.
    return $stmt->fetchAll();     // ‚Üê Retorna todos os resultados
}





 
 
 
 
 
 
 
 
 
 public/
‚îÇ
‚îú‚îÄ‚îÄ index.php      # entrada principal
‚îú‚îÄ‚îÄ home.html      # p√°ginas est√°ticas
‚îú‚îÄ‚îÄ contato.html
‚îú‚îÄ‚îÄ css/
‚îú‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ img/










√ìTIMO! O servidor est√° aceitando conex√µes sem erros PHP! Isso √© um grande progresso.


Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> curl http://localhost:8001/api/produtos


StatusCode        : 200
StatusDescription : OK
Content           : Erro MySQL: SQLSTATE[HY000] [1045] Access denied for user 'userAdmin'@'localhost' (using
                    password: YES)
RawContent        : HTTP/1.1 200 OK
                    Host: localhost:8001
                    Connection: close
                    Access-Control-Allow-Origin: *
                    Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
                    Access-Control-Allow-Headers: Content-Type
                    Con...
Forms             : {}
Headers           : {[Host, localhost:8001], [Connection, close], [Access-Control-Allow-Origin, *],
                    [Access-Control-Allow-Methods, GET, POST, PUT, DELETE, OPTIONS]...}
Images            : {}
InputFields       : {}
Links             : {}
ParsedHtml        : mshtml.HTMLDocumentClass
RawContentLength  : 103


Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> cd "C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends"
PS C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends> php -S localhost:8001 index.php
[Sun Oct 26 23:44:30 2025] PHP 8.4.14 Development Server (http://localhost:8001) started
[Sun Oct 26 23:44:36 2025] [::1]:11096 Accepted
[Sun Oct 26 23:44:36 2025] [::1]:11096 Closing





cd "C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends"

php -S localhost:8001 index.php

curl http://localhost:8001/api/produtos //teste do caminho da api no fecth


"C:\php\php.ini"
extension_dir = "C:\php\ext"
extension=pdo_mysql
extension=mysqli


# Testar MySQL
php -m | findstr "mysql"

# Testar cURL
php -m | findstr "curl"

# Testar GD
php -m | findstr "gd"

# Testar JSON
php -m | findstr "json"


O Windows PowerShell
Copyright (C) Microsoft Corporation. Todos os direitos reservados.

Instale o PowerShell mais recente para obter novos recursos e aprimoramentos! https://aka.ms/PSWindows

PS C:\Users\rodri> curl http://localhost:8001/api/produtos


StatusCode        : 200
StatusDescription : OK
Content           : {
                        "success": true,
                        "data": [
                            {},
                            {},
                            {},
                            {},
                            {},
                            {},
                            {},
                            {}
                        ],
                        "total": 8,
                        "message": "Produtos carregados com suces...
RawContent        : HTTP/1.1 200 OK
                    Host: localhost:8001
                    Connection: close
                    Access-Control-Allow-Origin: *
                    Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
                    Access-Control-Allow-Headers: Content-Type
                    Con...
Forms             : {}
Headers           : {[Host, localhost:8001], [Connection, close], [Access-Control-Allow-Origin, *],
                    [Access-Control-Allow-Methods, GET, POST, PUT, DELETE, OPTIONS]...}
Images            : {}
InputFields       : {}
Links             : {}
ParsedHtml        : mshtml.HTMLDocumentClass
RawContentLength  : 205



PS C:\Users\rodri>










O servidor PHP built-in √© apenas tempor√°rio - para quando voc√™ executa o comando.
Servidor Tempor√°rio:
cmd
php -S localhost:8000
Voc√™ precisa iniciar o servidor PHP NA MESMA PASTA onde est√° seu arquivo .php
Nao pode fecahr cmd se nao apara de rodar o servidor


"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\backs-ends\app\core\testDatabase.php"
"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE\"
http://localhost:8000/testDatabase.php
<?php
$host = 'localhost';
$dbname = 'loja_tenis';
$username = 'userAdminBig';
$password = 'secsistemas37666451829369Rr@';

try {
    $pdo = new PDO("mysql:host=$host;dbname=$dbname", $username, $password);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    echo "Conex√£o bem-sucedida!";
} catch (PDOException $e) {
    echo "Erro: " . $e->getMessage();
}
?>  



php -S localhost:8001 index.php
curl http://localhost:8001/api/produtos







"C:\Users\rodri\OneDrive\√Årea de Trabalho\T.I\PROJETOS\PROJETO-TENIS.STORE"
cd C:\Users\rodri\Downloads
php -S localhost:8000
http://localhost:8000/phptest.php

php
<?php
echo "PHP funcionando! Vers√£o: " . PHP_VERSION;
phpinfo();
?>





# Todos os produtos
curl http://localhost/loja_tenis/produtos

# Produto espec√≠fico
curl http://localhost/loja_tenis/produtos/1

# Buscar por nome
curl "http://localhost/loja_tenis/produtos/buscar?nome=tenis"

# Estat√≠sticas
curl http://localhost/loja_tenis/produtos/estatisticas





// Buscar todos os produtos
fetch('http://localhost/loja_tenis/produtos')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            data.data.forEach(produto => {
                console.log(produto.getNomeProduto());
            });
        }
    });

// Buscar produto espec√≠fico
fetch('http://localhost/loja_tenis/produtos/15')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Produto:', data.data);
        }
    });







                    --FLUXO--


// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Root (roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
    return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real






                    --TIPOS DE USUARIO--

‚ÄúUsu√°rio master‚Äù, ‚Äúusu√°rio cliente‚Äù, ‚Äúusu√°rio funcion√°rio‚Äù...
Esses n√£o s√£o sistemas diferentes, s√£o n√≠veis de acesso diferentes dentro do mesmo sistema.

Como isso funciona na pr√°tica:

Voc√™ tem uma tabela de usu√°rios s√≥, por exemplo:

id	nome	        email	    senha_hash	tipo
1	Jo√£o Silva	joao@email.com   (hash)	    master
2	Ana Souza	ana@email.com    (hash)	    funcionario
3	Pedro Lima	pedro@email.com  (hash)	    cliente

O campo tipo (ou role) define o ‚Äún√≠vel‚Äù do usu√°rio.
Assim, quando ele faz login, o backend sabe se ele √© master, funcionario ou cliente.

‚öôÔ∏è Como aplicar isso:
No login, voc√™ valida o usu√°rio normalmente.
Depois, dependendo do tipo, voc√™ mostra ou esconde partes do sistema.
Exemplo:
master ‚Üí pode acessar tudo.
funcionario ‚Üí pode gerenciar produtos, mas n√£o excluir usu√°rios.
cliente ‚Üí s√≥ v√™ produtos e faz pedidos.



üí° Implementa√ß√£o simples:

No front-end, voc√™ pode usar algo assim:

if (user.tipo === 'master') {
  mostrarBotaoAdmin();
} else if (user.tipo === 'funcionario') {
  mostrarPainelFuncionario();
} else {
  mostrarTelaCliente();
}

No back-end, voc√™ tamb√©m pode validar rotas:

if ($user['tipo'] !== 'master') {
  return ['success' => false, 'message' => 'Acesso negado'];
}






üö¶ Fluxo b√°sico de login:

Front-end envia o email e senha via fetch():
fetch('/backend/public/index.php?action=login', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({email: 'joao@email.com', senha: '123456'})
})
.then(r => r.json())
.then(console.log);


Controller recebe isso e chama o Service:
class UserController {
  private $service;
  public function __construct() { $this->service = new UserService(); }

  public function login($data) {
    return $this->service->login($data['email'], $data['senha']);
  }
}


Service valida os dados e consulta o Repository:
class UserService {
  private $repo;
  public function __construct() { $this->repo = new UserRepository(); }

  public function login($email, $senha) {
    $user = $this->repo->findByEmail($email);
    if (!$user) return ['success' => false, 'message' => 'Usu√°rio n√£o encontrado'];

    if (password_verify($senha, $user['senha_hash'])) {
      return ['success' => true, 'user' => $user];
    } else {
      return ['success' => false, 'message' => 'Senha incorreta'];
    }
  }
}


Repository busca o usu√°rio no banco (ou JSON):
class UserRepository {
  private $db;
  public function __construct() { $this->db = Database::getInstance(); }

  public function findByEmail($email) {
    $data = $this->db->getData();
    foreach ($data['users'] as $u) {
      if ($u['email'] === $email) return $u;
    }
    return null;
  }
}


üîí Resultado:
Se o login for v√°lido ‚Üí o back retorna o usu√°rio e o tipo (ex: master).
O front-end guarda isso (ex: no localStorage) e redireciona pra tela certa.












DEBUG NO F12 E SERVIDOR PHP


starta o servidor php no caminho do index php, verifica caminho da api dentro do role inteiro e inicia o live server

cd "C:\Users\rodrigo\Downloads\PROJETO-TENIS.STORE\backs-ends"
php -S localhost:8001 index.php

basta voc√™ mudar os caminhos dos endpoints no fetch para os que existem no seu backend e pronto
O editar, excluir e cadastrar s√£o as opera√ß√µes CRUD b√°sicas: cadastrar cria novos produtos, editar modifica os existentes e excluir remove produtos do sistema - voc√™ s√≥ precisa conectar cada um ao endpoint correto da sua API.

//as rotas e tipos de usuario estao intimamente ligados, usario tipo cliente e funcionario devem ter rotas diferentes/valida√ßoes diferentes












-----------------------------------------------------------------------------------------------------------------------------






RESUMO DE FETCH, FORM, HTTP, ENDPOINT E ROUTE/index.php + EXEMPLOS DE PLANTA COM EXPLICA√áOES POR PASTA, EXPLICA√áOES TEORICAS DE SEGURAN√áA E EXPLICA√áOES RESUMIDAS DE POO 






                                                                             --DESENVOLVIMENTO BACK END GERAL--




                       -TIPOS DE DESENVOLVIMENTO-

PHP, Node.js, Python, Java, Ruby, Go, etc. ‚Üí cada linguagem tem seus frameworks e maneiras de trabalhar no back-end.

Estilos de desenvolvimento:
Monol√≠tico: tudo (c√≥digo, regras, autentica√ß√£o, banco) est√° dentro de um √∫nico projeto. Simples de come√ßar, mas dif√≠cil de escalar.
Modular: divide em m√≥dulos independentes, mas ainda dentro de uma mesma aplica√ß√£o. Divisao de Front e back.
Microservi√ßos: cada parte do sistema √© um servi√ßo separado (ex.: autentica√ß√£o em um servi√ßo, pagamentos em outro). Escal√°vel, mas complexo.
Serverless (Fun√ß√µes em Nuvem): voc√™ escreve fun√ß√µes que s√≥ rodam quando chamadas (AWS Lambda, Firebase Functions). Bom para projetos pequenos ou que precisam escalar r√°pido.


                       -MVC(Model-View-Controller)-

O que √©: Padr√£o de arquitetura de software que separa a aplica√ß√£o em 3 componentes:
Componentes:
Model: Gerencia dados e regras de neg√≥cio
View: Interface do usu√°rio (o que √© exibido)
Controller: Intermedi√°rio que processa entradas e coordena Model/View
 ‚îú‚îÄ‚îÄ Model      ‚Üí implementa o CRUD (acesso ao banco de dados)
 ‚îú‚îÄ‚îÄ View       ‚Üí mostra os dados (HTML, JSON, etc.)
 ‚îî‚îÄ‚îÄ Controller ‚Üí exp√µe as rotas da API RESTful (recebe requisi√ß√µes HTTP)



                      -CRUD (Create, Read, Update, Delete)-

O que √©: Conjunto das 4 opera√ß√µes b√°sicas para manipula√ß√£o de dados em qualquer aplica√ß√£o.

Opera√ß√µes:
Create (Criar): Inserir novos registros (ex: INSERT no SQL)
Read (Ler): Consultar e visualizar dados (ex: SELECT no SQL)
Update (Atualizar): Modificar registros existentes (ex: UPDATE no SQL)
Delete (Excluir): Remover registros (ex: DELETE no SQL)
Aplica√ß√£o: Base de quase todos os sistemas que manipulam dados - desde redes sociais at√© sistemas banc√°rios.

CRUD √© um conceito que representa um conjunto de opera√ß√µes b√°sicas sobre dados.
CRUD = conceito de opera√ß√µes b√°sicas com dados (seja num banco de dados, arquivos, mem√≥ria etc).
√â independente de linguagem ou tecnologia (existe em SQL, Java, Python, etc.).
√â base para qualquer sistema que lida com dados: como um cadastro de usu√°rios, produtos, pedidos,







-------------------------------------------------------------------------------------------------------------------------------------------------







                                                                             --DESENVOLVIMENTO BACK END DETALHADO--




                          -PROTOCOLO HTTP-

O protocolo HTTP define v√°rios m√©todos, mas os mais usados em APIs (e que o PHP entende de boa) s√£o:
GET ‚Üí pegar dados
POST ‚Üí enviar/criar dados
PUT ‚Üí atualizar dados
DELETE ‚Üí excluir dados

Esses 4 ficaram famosos porque s√£o a base do estilo REST.
Mas existem outros m√©todos v√°lidos tamb√©m, como:
PATCH (atualizar parcialmente)
OPTIONS (perguntar ao servidor quais m√©todos s√£o permitidos)
HEAD (igual ao GET, mas s√≥ traz os headers)

Ele consegue lidar com qualquer m√©todo HTTP que o navegador/fetch mandar, contanto que seja um m√©todo reconhecido pelo protocolo HTTP.
O que voc√™ n√£o pode √© inventar m√©todos novos (tipo MEU_METODO), porque a√≠ o protocolo n√£o entende.

Exemplo de l√≥gica dentro de um √∫nico endpoint (api.php):
GET /api.php ‚Üí listar usu√°rios
POST /api.php ‚Üí criar usu√°rio
PUT /api.php ‚Üí atualizar usu√°rio
DELETE /api.php ‚Üí deletar usu√°rio

O jeito mais organizado √©:
1 arquivo ou 1 rota por entidade.
Exemplo:
api/usuarios.php ‚Üí cuida s√≥ de usu√°rios
api/produtos.php ‚Üí cuida s√≥ de produtos
api/pedidos.php ‚Üí cuida s√≥ de pedidos




                  -COMO O SISTEMA SABE A ROTA ENTRE FECHT/FORM E O ENDPOINT-

Assim como no fetch(), o backend identifica a rota (action) e o m√©todo (method):
Se o formul√°rio envia com GET, os dados chegam em $_GET.
Se o formul√°rio envia com POST, os dados chegam em $_POST.

EXEMPLO EM PHP:
header("Content-Type: application/json");
if ($_SERVER["REQUEST_METHOD"] === "GET") {
    echo json_encode(["msg" => "Voc√™ fez GET", "dados" => $_GET]);
} elseif ($_SERVER["REQUEST_METHOD"] === "POST") {
    echo json_encode(["msg" => "Voc√™ fez POST", "dados" => $_POST]);
}




                   -FECHT API MANDANDO REQUISI√áOES DO FRONT PARA O BACK EM ENDPOINTS-

O fetch() √© a ferramenta (o m√©todo de transporte), mas o que voc√™ coloca dentro dele depende totalmente da sua inten√ß√£o.
O conte√∫do trocado entre frontend e backend geralmente √© JSON (mas poderia ser HTML, XML, texto, imagem, etc., dependendo do que voc√™ configurar).
O fetch chama o PHP, o PHP responde JSON, e o JS usa esses dados no HTML.


Exemplo simples (GET):
//No fetch(), se voc√™ n√£o especificar method, o padr√£o √© GET.
fetch("http://localhost/api.php")
<script>
  // Pedindo dados do PHP
  fetch("http://localhost/api.php")
    .then(response => response.json()) // transforma a resposta em JSON
    .then(data => {
      console.log(data); // aqui j√° √© objeto JS normal
      document.body.innerHTML += `<p>Nome: ${data.nome}</p>`;
    })
    .catch(error => console.error("Erro:", error));
</script>


E o PHP (api.php) poderia ser:
header("Content-Type: application/json");
echo json_encode([
  "nome" => "Rodrigo",
  "idade" => 25
]);


Outro exemplo:
<script>
fetch("https://api.exemplo.com/dados", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({ nome: "Ana", idade: 25 })
})
.then(res => res.json())
.then(dados => console.log(dados));
<script>



üîπ 1. O que √© o fetch("http://localhost/api.php")?
Esse endere√ßo (http://localhost/api.php) √© a rota que o front-end vai chamar.
N√£o √© ‚Äúum arquivo JSON‚Äù que voc√™ j√° tem guardado; √© s√≥ um caminho para o back-end responder alguma coisa.
O que o servidor (PHP, Node, Python etc.) responder depende do c√≥digo dentro dele.
Ou seja, quando voc√™ faz fetch("http://localhost/api.php"), o navegador manda uma requisi√ß√£o pro servidor dizendo:
‚ÄúEi, me d√™ a resposta desse endere√ßo aqui.‚Äù
E o PHP no api.php decide o que devolver (pode ser JSON, HTML, texto, at√© uma imagem se quiser).
No fetch(), se voc√™ n√£o especificar method, o padr√£o √© GET.
Por isso, no seu exemplo:
fetch("http://localhost/api.php")

üîπ 2. O que faz header("Content-Type: application/json") no PHP?
Esse comando s√≥ serve para avisar ao navegador:
‚ÄúO que estou mandando de volta n√£o √© HTML, √© JSON.‚Äù
Isso √© importante porque:
Se fosse HTML, o navegador tentaria renderizar como p√°gina.
Como √© JSON, o 4. Como o sistema sabe qual c√≥digo executar?

Ele sabe porque voc√™ chama o endere√ßo exato (/api.php, /users.php, /produtos/listar.php etc.).
Dentro de cada endpoint PHP, voc√™ pode escrever regras:
Se for GET ‚Üí devolve lista.
Se for POST ‚Üí cria um novo item.

Se for /api.php?user=1 ‚Üí devolve s√≥ o usu√°rio 1.
Exemplo de PHP que decide o que devolver:
header("Content-Type: application/json");
if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    echo json_encode(["msg" => "Voc√™ fez um GET"]);
} elseif ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $body = json_decode(file_get_contents("php://input"), true);
    echo json_encode(["msg" => "Voc√™ fez um POST", "recebi" => $body]);
}
navegador sabe que √© um texto estruturado de dados e o JS pode usar response.json() no fetch.







                     -FORM HTML MANDANDO REQUISI√áOES DO FRONT PARA O BACK EM ENDPOINTS-


Um formul√°rio HTML √© outra forma de o frontend enviar dados para o backend.

Estrutura b√°sica de um <form>
<form action="http://localhost/api.php" method="GET">
  <input type="text" name="nome" value="Rodrigo">
  <input type="number" name="idade" value="25">
  <button type="submit">Enviar</button>
</form>
//explicando
action ‚Üí para onde enviar (ex: api.php).
method ‚Üí tipo de requisi√ß√£o (GET ou POST).
name dos inputs ‚Üí chaves que o backend recebe.


.EXEMPLO COM GET:
HTML:
<form action="http://localhost/api.php" method="GET">
  <input type="text" name="nome" placeholder="Digite seu nome">
  <button type="submit">Enviar</button>
</form>

O navegador manda para:
http://localhost/api.php?nome=Rodrigo

PHP (api.php):
header("Content-Type: application/json");
echo json_encode([
  "nome_recebido" => $_GET["nome"] ?? "n√£o informado"
]);

Resultado no navegador:
{ "nome_recebido": "Rodrigo" }


.EXEMPLO COM POST(dados no corpo da requisi√ß√£o):
HTML:
<form action="http://localhost/api.php" method="POST">
  <input type="text" name="nome" placeholder="Digite seu nome">
  <input type="number" name="idade" placeholder="Digite sua idade">
  <button type="submit">Enviar</button>
</form>

PHP (api.php):
header("Content-Type: application/json");
echo json_encode([
  "nome_recebido" => $_POST["nome"] ?? "n√£o informado",
  "idade_recebida" => $_POST["idade"] ?? "n√£o informada"
]);

Resultado no navegador:
{ "nome_recebido": "Ana", "idade_recebida": "25" }







                        -DIFEREN√áA E IGUALDADES ENTRE FETCH E FORM-


. PONTOS EM COMUM:
Objetivo Principal: Ambos s√£o usados para coletar e enviar dados para um servidor.
Fonte dos Dados: Tanto um formul√°rio tradicional quanto uma requisi√ß√£o Fetch geralmente obt√™m seus dados de elementos de formul√°rio HTML (<input>, <select>, <textarea>) preenchidos pelo usu√°rio.
Protocolo de Comunica√ß√£o: Ambos podem usar os m√©todos HTTP GET e POST (embora Fetch seja muito mais flex√≠vel e possa usar PUT, DELETE, etc.).
Capacidade de Processamento de Resposta: Ambos podem lidar com a resposta do servidor. A diferen√ßa crucial est√° em como isso √© feito.
Basicamente o front end envia requisi√ßoes pro back atraves do http no java script json e o back reposnde em php json

                  
. DIFEREN√áAS:
Use form: quando quiser algo simples, envio direto de dados, sem JS.
Use fetch: quando precisar de mais controle, tratar a resposta sem recarregar a p√°gina, integrar APIs.
A diferen√ßa para o fetch() √© que:
O <form> funciona sozinho, sem precisar de JavaScript.
O navegador monta a requisi√ß√£o HTTP e envia para o servidor.
O method pode ser GET ou POST.

Fetch API (AJAX moderno)
Como funciona: JavaScript que faz requisi√ß√µes HTTP ass√≠ncronas sem recarregar a p√°gina
Comunica√ß√£o: Aplica√ß√£o ‚Üí API (geralmente JSON)
Experi√™ncia do usu√°rio: Mais fluida, sem recarregar a p√°gina
Exemplo:
// Frontend fazendo requisi√ß√£o com Fetch
fetch('https://api.meusite.com/usuarios', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    nome: 'Jo√£o',
    email: 'joao@email.com'
  })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Erro:', error));


Formul√°rios HTML (tradicional)
Como funciona: Envio tradicional de dados com recarregamento da p√°gina
Comunica√ß√£o: Navegador ‚Üí Servidor (HTML)
Experi√™ncia do usu√°rio: Recarrega a p√°gina completamente
Exemplo:
<!-- Formul√°rio HTML tradicional -->
<form action="/cadastrar_usuario.php" method="POST">
  <input type="text" name="nome" placeholder="Nome">
  <input type="email" name="email" placeholder="Email">
  <button type="submit">Cadastrar</button>
</form>






                      -ENDPOINT-

Endpoint ‚Üí √© s√≥ o endere√ßo (URL) que o fetch ou form vai chamar. Exemplo: http://localhost/api.php.
o endpoint √© s√≥ o caminho at√© o arquivo/rota do servidor
Basicamente o front end envia requisi√ßoes pro back atraves do http no java script json e o back reposnde em php json

Fluxo normal:
O JavaScript (frontend) faz a requisi√ß√£o pro endpoint. //Ele pode mandar dados no corpo da requisi√ß√£o (em JSON ou outro formato).
O PHP (backend) recebe essa requisi√ß√£o, processa e devolve uma resposta. //Normalmente, quando √© API, essa resposta tamb√©m √© JSON.

Ou seja:
fetch ‚Üí chama o endpoint (PHP)
manda dados (opcionalmente em JSON)
 o PHP responde (quase sempre em JSON tamb√©m, se for API).


EXEMPLOS:

php e form=
$nome = $_POST['nome'] ?? '';
$idade = $_POST['idade'] ?? '';
if ($nome && $idade) {
    echo "Ol√° $nome, voc√™ tem $idade anos!";
} else {
    echo "Preencha todos os campos!";
}

form=
<form action="api.php" method="POST">
  <input type="text" name="nome" placeholder="Nome">
  <input type="number" name="idade" placeholder="Idade">
  <button>Enviar</button>
</form>


php e fetch=
header("Content-Type: application/json");
$nome = $_POST['nome'] ?? $_GET['nome'] ?? '';
$idade = $_POST['idade'] ?? $_GET['idade'] ?? '';
echo json_encode([
  "mensagem" => $nome && $idade ? "Ol√° $nome, $idade anos!" : "Faltam dados"
]);

fetch=
<script>
  // POST
  document.getElementById("formPost").onsubmit = e => {
    e.preventDefault();
    fetch("api.php", { method:"POST", body:new FormData(e.target) })
      .then(r => r.json())
      .then(d => document.getElementById("respostaPost").innerText = d.mensagem);
  };
  // GET
  document.getElementById("btnGet").onclick = () => {
    fetch("api.php?nome=Jo√£o&idade=30")
      .then(r => r.json())
      .then(d => document.getElementById("respostaGet").innerText = d.mensagem);
  };
</script>






                       -LOCALIZA√áAO E ROTEAMENTO DE REQUEST(FORM E FETCH) E RESPONSE(API.PHP)-

EXEMPLO RELATIVO EM RELA√áAO AO LOCAL DO ENDPOINT SEM O USO DO INDEX.PHP COM ROUTE:
<form action="../../BackEnd/php/cadastro.php" method="POST">
  Nome: <input type="text" name="nome"><br>
  Email: <input type="email" name="email"><br>
  <button type="submit">Cadastrar</button>
</form>


EXEMPLO USANDO O INDEX PARA ROTEAR:
A ideia √©:
Voc√™ deixa todos os requests passarem pelo index.php.
O form aponta para index.php, e voc√™ cria uma regra para direcionar cada a√ß√£o ao PHP certo.
Exemplo:
<form action="index.php" method="POST">
  <input type="hidden" name="acao" value="cadastro">
  Nome: <input type="text" name="nome"><br>
  Email: <input type="email" name="email"><br>
  <button type="submit">Cadastrar</button>
</form>





                       -ROUTES NO INDEX.PHP BACKEND(index.php)-	

O arquivo routes existe quando √© usado uma linguagem pura e sem framework tendo o proprio dev definir as rotas no arquivo manualmente.
Basicamente o front end envia requisi√ßoes pro back atraves do http no java script json e o back reposnde em php json
A Rota (Route) √© a ponte que conecta o M√©todo HTTP (do fetch) com o M√©todo do Controller (que processar√° a request).
Ele l√™ a rota (URI + m√©todo HTTP) e mapeia para um Controller + m√©todo.
Qualquer fonte de seguran√ßa de um back end quando se trata de um desenvolvimenteo sem frameworks tera que ser feita manualmente por exemplo: a valida√ßao ($request->validate()), sendo feita no controller por exemplo, outras maneiras envolvem o proprio front ou uma pasta separada e com referencias no controller.
Toda requisi√ß√£o (ex: http://localhost/backend/public/index.php/users/1) entra pelo public/index.php ‚Üí esse √© o Front Controller.
Fluxo:
O index.php chama o Router (core/Router.php).
O Router olha a URL e decide qual Controller deve ser chamado.
O Controller usa Models (e possivelmente Services/Repositories) para processar regras de neg√≥cio.
O Controller retorna algo (JSON no caso de API RESTful).


EXEMPLO DE ROUTE:
<?php
// config/routes.php
require_once __DIR__ . '/../app/controllers/UserController.php';
// Captura a URL e o m√©todo
$path   = $_SERVER['REQUEST_URI'];
$method = $_SERVER['REQUEST_METHOD'];
// Rota: GET /usuarios
if ($method === 'GET' && $path === '/usuarios') {
    $controller = new UserController();
    $controller->index();
}
// Rota: POST /usuarios
elseif ($method === 'POST' && $path === '/usuarios') {
    $controller = new UserController();
    $controller->store();
}
// Rota: GET /usuarios/{id}
elseif ($method === 'GET' && preg_match('/^\/usuarios\/(\d+)$/', $path, $matches)) {
    $userId = $matches[1];
    $controller = new UserController();
    $controller->show($userId);
}
// Se nenhuma rota bater, retorna 404
else {
    http_response_code(404);
    echo json_encode(['error' => 'Rota n√£o encontrada']);
}



EXEMPLO DE INDEX.PHP:
<?php
// public/index.php

// 1. Inclui os arquivos necess√°rios (o "import" do PHP)
require_once __DIR__ . '/../app/controllers/UserController.php';
// Futuramente voc√™ vai incluir seu Router.php aqui tamb√©m

// 2. Captura o que o usu√°rio est√° pedindo
$path = $_SERVER['REQUEST_URI']; // Pega a URL (ex: /usuarios)
$method = $_SERVER['REQUEST_METHOD']; // Pega o m√©todo (GET, POST)

// 3. ROTEAMENTO MANUAL ("If√£o" Brabo)
// Aqui voc√™ define QUAL URL com QUAL M√âTODO chama QUAL FUN√á√ÉO
// Este √© o cora√ß√£o do seu sistema de rotas caseiro.

// Rota: GET /usuarios
if ($method === 'GET' && $path === '/usuarios') {
    $controller = new UserController(); // Cria o controller
    $controller->index(); // Chama o m√©todo index()
}
// Rota: POST /usuarios
elseif ($method === 'POST' && $path === '/usuarios') {
    $controller = new UserController();
    $controller->store();
}
// Rota: GET /usuarios/algum-id (ex: /usuarios/25)
elseif ($method === 'GET' && preg_match('/^\/usuarios\/(\d+)$/', $path, $matches)) {
    $userId = $matches[1]; // Pega o ID da URL
    $controller = new UserController();
    $controller->show($userId); // Passa o ID para o m√©todo
}
// Se n√£o encontrou nenhuma rota... ERRO 404
else {
    http_response_code(404);
    echo 'P√°gina n√£o encontrada, parceiro!';
}









---------------------------------------------------------------------------------------------------------------------------------------------------------









                                                      --CYBERSEGURAN√áA GERAL EM BACK END--


Quem hospeda o site normalmente s√≥ exp√µe o HTML, CSS, JavaScript e chamadas de API no navegador. Os arquivos do back-end (PHP, Node.js, Python, banco de dados etc.) ficam totalmente no servidor e n√£o s√£o vis√≠veis para quem acessa o site.
Sim, exatamente ‚Äî se algu√©m quisesse tentar invadir ou explorar um site, ele teria que atacar as APIs ou encontrar alguma vulnerabilidade exposta no front-end que d√™ acesso ao back-end.
Qualquer fonte de seguran√ßa de um back end quando se trata de um desenvolvimenteo sem frameworks tera que ser feita manualmente por exemplo: a valida√ßao ($request->validate()), sendo feita no controller por exemplo, outras maneiras envolvem o proprio front ou uma pasta separada e com referencias no controller.


üîí FORMAS DE IMPLANTAR SEGURAN√áA NO BACK END:

1. Controle de Acesso e Autentica√ß√£o
Garante que apenas usu√°rios autorizados acessem recursos.
Pr√°tica:
Use autentica√ß√£o robusta (OAuth2, JWT, SSO).
Implemente roles e permissions (ex: admin, user).
Expire tokens/sess√µes em tempo adequado.

2. Valida√ß√£o e Saneamento de Dados
Nunca confie em entrada do usu√°rio.
Pr√°tica:
Valide formato de inputs (emails, n√∫meros, datas).
Bloqueie caracteres perigosos contra SQL Injection, XSS e afins.
Use whitelists (permitir s√≥ o que √© v√°lido) em vez de blacklists.

3. Prote√ß√£o de Dados Sens√≠veis
Senhas e dados cr√≠ticos nunca devem estar em texto puro.
Pr√°tica:
Armazene senhas com hash forte e salting.
Nunca exponha chaves de API ou segredos no c√≥digo.
Use vari√°veis de ambiente e cofres de segredo (Vault, AWS Secrets Manager).

4. Comunica√ß√£o Segura
Evite tr√°fego interceptado.
Pr√°tica:
Sempre use HTTPS/TLS.
Bloqueie protocolos inseguros (HTTP simples, SSL antigo).
Proteja cookies com HttpOnly, Secure e SameSite.

5. Tratamento de Erros e Logs
Erros podem vazar informa√ß√µes sens√≠veis.
Pr√°tica:
Nunca exponha stack traces para o usu√°rio.
Registre erros em logs internos.
Monitore logs em tempo real para ataques (SIEM, ELK, etc.).

6. Gerenciamento de Depend√™ncias
Bibliotecas externas podem trazer vulnerabilidades.
Pr√°tica:
Atualize pacotes regularmente.
Use scanners (Snyk, OWASP Dependency-Check).
Evite pacotes sem manuten√ß√£o ou de fontes duvidosas.

7. Pol√≠ticas de Rate Limiting e Prote√ß√£o contra Ataques
Prevenir abusos e nega√ß√£o de servi√ßo.
Pr√°tica:
Limite tentativas de login (para evitar brute-force).
Aplique rate limiting em APIs.
Use firewalls de aplica√ß√£o (WAF).












---------------------------------------------------------------------------------------------------------------------------------------------------------



                                                8---EXEMPLO PRATICO DE UM PROJETO WEB COM PHP---8
          


Quando o back-end e front-end est√£o separados, a comunica√ß√£o tem que ser via API RESTful. O back-end vira um servi√ßo de dados e o front-end vira um cliente independente que consome esses dados.
Se voc√™ quer algo simples e direto, pode fazer o front-end apenas com a pasta assets/ e o index.html. Essa √© a abordagem tradicional e v√°lida para projetos menores.
Views n√£o fazem sentido nessa arquitetura porque estar√≠amos "separando o front dentro do back", o que √© contradit√≥rio quando o objetivo √© justamente separar totalmente os dois.
N√£o somos obrigados a seguir uma estrutura fixa de constru√ßao de projetos.
A conex√£o entre o backend e o banco de dados segue uma arquitetura em camadas bem definida, onde cada parte tem responsabilidades espec√≠ficas:
O Database atua como a funda√ß√£o - √© a √∫nica camada que realmente conhece e interage diretamente com o banco de dados. Ele abstrai toda a complexidade das conex√µes, seja SQLite para desenvolvimento ou MySQL para produ√ß√£o.
Os Repositories funcionam como intermedi√°rios especializados - cada entidade do sistema (usu√°rios, produtos) tem seu repository que traduz as opera√ß√µes de neg√≥cio em comandos espec√≠ficos do banco, usando os m√©todos padronizados fornecidos pelo Database.
Os Controllers mant√™m dist√¢ncia do banco - sua fun√ß√£o √© lidar com requisi√ß√µes HTTP e respostas, delegando toda a l√≥gica de dados para camadas mais internas. Eles s√£o os "porta-vozes" do sistema, focados em comunica√ß√£o externa.
Essa separa√ß√£o cria um fluxo claro: requisi√ß√µes entram pelos controllers, passam pelos services para valida√ß√µes de neg√≥cio, s√£o convertidas em opera√ß√µes de banco pelos repositories, e finalmente executadas pelo database. O resultado √© um sistema onde mudan√ßas no banco afetam apenas o database, mudan√ßas nas queries afetam apenas os repositories, e o restante do c√≥digo permanece intacto.
Controller: recebe a requisi√ß√£o (ex.: POST /usuarios/cadastrar) e valida dados b√°sicos de entrada.
Service: cont√©m a l√≥gica de neg√≥cio ‚Üí por exemplo: verificar se o e-mail j√° existe, criptografar senha, aplicar regras de cadastro.
Repository (ou DAO): faz apenas o acesso ao banco (INSERT, SELECT, UPDATE, DELETE).

//back e front separados(api restfull e sem view) - php puro - seguran√ßa por conta propria no middleware 
meu_projeto/
‚îÇ
‚îú‚îÄ‚îÄ backend/                  # API RESTful (PHP puro COMPATIVEL COM A HOSTGATOR)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Model.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Database.php
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/      # Controladores API (retornam JSON)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Api/          # Pasta espec√≠fica para APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserController.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductController.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/           # Models (entidades de neg√≥cio)
‚îÇ   ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ User.php      # Entidade User
‚îÇ   ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ Product.php   # Entidade Product
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/         # Camada de Servi√ßos  
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/     # Padr√£o Repository
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/               # Configura√ß√µes
‚îÇ       ‚îî‚îÄ‚îÄ routes.php
‚îÇ   ‚îî‚îÄ‚îÄ public/
‚îÇ       ‚îî‚îÄ‚îÄ index.php         # Front Controller da API
‚îÇ
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ frontend/                 # Aplica√ß√£o Front-End (Separada)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ html/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ js/ 
‚îÇ   ‚îî‚îÄ‚îÄ ‚îî‚îÄ‚îÄ images/
‚îÇ   
‚îÇ
‚îî‚îÄ‚îÄ vendor/                   # Depend√™ncias (Composer)










Front-end faz o fetch()- front esse que pode qualquer coisa q manda uma requisi√ßao pra esse fecth
‚Üí Executa o fetch() para chamar a API.
‚Üí Sempre envia junto os dados do usu√°rio (como token, id e tipo).

Controller
‚Üí Valida se a requisi√ß√£o cont√©m todos os dados obrigat√≥rios, tanto da API quanto do usu√°rio.
‚Üí Se faltar algo, a requisi√ß√£o √© rejeitada imediatamente.

Service
‚Üí Valida o n√≠vel de acesso do usu√°rio com base nos dados recebidos (ex: apenas administradores podem executar certas a√ß√µes).
‚Üí S√≥ continua o fluxo se o usu√°rio tiver permiss√£o.

Repository
‚Üí Executa apenas a parte de acesso ao banco (SQL).
‚Üí N√£o se preocupa com quem fez a requisi√ß√£o nem com permiss√µes ‚Äî recebe dados prontos e confi√°veis.


Sempre quando executa um fecth pra alguma api de admin, os dados do usuario tambem sao enviados 
e √© validado no controler se todos os dados estao sendo enviados(da api e do user) se nao funciona 
e no service eu valido o nivel de usuario dentro desses dados








                    --FLUXO--


// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Route e Index(roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
        return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real








 
                      -RESUMO-

Basicamente a pasta core cria as classes pais(services, repositories, controllers, databases, models) e √© criado classes das entidades de negocio(User) dentro da pasta models, as duas se relacionam nas pastas(services, repositories, controllers...) por heran√ßa por parte dos pais e composi√ßao por parte dos models , assim por exemplo: 

//PASTA CONTROLLER:
//UserController.php
class UserController extends Controller { //extends √© heran√ßa
public function create() {
    // ‚úÖ RECEBE a requisi√ß√£o HTTP
    $data = $this->getRequestBody();        
    // ‚úÖ CRIA a entidade User (objeto em mem√≥ria)
    $user = new \App\Models\User();
    $user->setName($data['name'])
         ->setEmail($data['email']);
    // ‚úÖ DELEGA para o Service
    $result = $this->userService->createUser($user);
    // ‚úÖ RESPONDE para o cliente
    $this->json($result, 201);
}}
//sponsabilidade: Receber HTTP ‚Üí Criar objeto ‚Üí Delegar ‚Üí Responder JSON



--EXEMPLO MAIS ROBUSTO:

Core/Controller.php (Classe Pai)
Muita gente coloca um Controller.php gen√©rico no core/ s√≥ porque viu em frameworks grandes, mas em PHP puro, ele nem sempre faz sentido.
<?php
namespace App\Core;
abstract class Controller {
// ‚úÖ Fornece m√©todos COMUNS para TODOS os controllers
    protected function json($data, $status = 200) {
        header('Content-Type: application/json');
        http_response_code($status);
        echo json_encode($data);
        // Converte array/PHP em JSON para resposta HTTP
    }    
    protected function getRequestBody() {
        return json_decode(file_get_contents('php://input'), true);        
        // Pega dados JSON do corpo da requisi√ß√£o e converte para array PHP
    }
}


Models/User.php (Entidade de Neg√≥cio)
<?php
namespace App\Models;
class User {
    private $id;
    private $name;
    private $email;
    // Getters e Setters
    public function getId() { return $this->id; }
    public function getName() { return $this->name; }
    public function getEmail() { return $this->email; }
    public function setName($name) { $this->name = $name; return $this; }
    public function setEmail($email) { $this->email = $email; return $this; }
    // ‚úÖ Representa um USU√ÅRIO do sistema
    // ‚úÖ Armazena DADOS (propriedades)
    // ‚úÖ Fornece ACESSO aos dados (getters/setters)
}


Controllers/Api/UserController.php (RECEBE/RESPONDE)
<?php
namespace App\Controllers\Api;
use App\Core\Controller;
use App\Services\UserService;
class UserController extends Controller { 
    private $userService;
    public function __construct() {
        $this->userService = new UserService(); // COMPOSI√á√ÉO // ‚úÖ Conecta com Service
    }
    public function create() {
        $data = $this->getRequestBody();  // ‚úÖ 1. RECEBE dados da requisi√ß√£o HTTP
        $user = new \App\Models\User();  // ‚úÖ 2. CRIA objeto User com os dados
        $user->setName($data['name'])
             ->setEmail($data['email']);             
        $result = $this->userService->createUser($user);// ‚úÖ 3. PEDE para Service processar
        $this->json($result, 201);         // ‚úÖ 4. ENVIA resposta JSON
    }
    public function index() {
        $users = $this->userService->getAllUsers();
        $this->json($users);
    }
}


Services/UserService.php (COMPOSI√á√ÉO)
<?php
namespace App\Services;
use App\Models\User;
use App\Repositories\UserRepository;
class UserService {  // N√ÉO herda de Service, √© independente
    private $userRepository
    public function __construct() {
        $this->userRepository = new UserRepository(); // ‚úÖ Conecta com Repository
    }
    public function createUser(User $user) {
        // ‚úÖ 1. VALIDA regras de neg√≥cio
        if (!$user->getName() || !$user->getEmail()) {
            throw new \Exception("Dados inv√°lidos");
        }
        // ‚úÖ 2. PEDE para Repository salvar no banco
        return $this->userRepository->save($user);
    }
    
    public function getAllUsers() {
        return $this->userRepository->findAll();
    }
}


Repositories/UserRepository.php (COMPOSI√á√ÉO)
<?php
namespace App\Repositories;
use App\Models\User;
use App\Core\Database;
class UserRepository {  // N√ÉO herda de Repository
    private $db;
    public function __construct() {
        $this->db = Database::getConnection(); // ‚úÖ Conecta com banco
    }
    public function save(User $user) {
        // ‚úÖ 1. PREPARA comando SQL
        $stmt = $this->db->prepare("INSERT INTO users...");
        // ‚úÖ 2. EXECUTA no banco
        $stmt->execute([$user->getName(), $user->getEmail()]);
        // ‚úÖ 3. ATUALIZA objeto com ID gerado
        $user->setId($this->db->lastInsertId());
        return $user;
    }
    public function findAll() {
        // Busca todos os usu√°rios
        $stmt = $this->db->query("SELECT * FROM users");
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }
}
OUTRO EXEMPLO DE POSITORY
// No Repository:
class UserRepository {
    private $db;
    public function __construct() {
        // ‚úÖ Pega a conex√£o do Database
        $this->db = Database::getInstance();
    }
    public function save($user) {
        // ‚úÖ Usa os m√©todos do Database
        return $this->db->insert(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            [$user->getName(), $user->getEmail()]
        );
    }
}




                   -PASTA POR PASTA-


core/Model.php 
√â a Mae, sendo referencia pra objetos criados em outras pastas como o caso dos models, assim implemtentando regras de negocio para entidades maes e consequentemente pros filhos tbm.
√â um arquivo √∫nico que cont√©m a l√≥gica comum que todos os models v√£o ter.
core/Model.php ‚Üí Classe gen√©rica/abstrata que serve de base.
models/* (User, Product, etc.) ‚Üí S√£o filhas dessa classe base, cada uma representando uma entidade/tabela do banco.



app/services/
√â a PASTA que cont√©m os servi√ßos.
Cada arquivo aqui representa um "conjunto de regras de neg√≥cio" espec√≠fico (UserService.php, PaymentService.php).
Eles cont√™m a l√≥gica complexa do sistema (c√°lculos, valida√ß√µes, fluxos) e coordenam a intera√ß√£o entre V√°rios Models/Repositories para realizar uma opera√ß√£o completa.
Faz a l√≥gica central da aplica√ß√£o.
Cuida da sanitiza√ß√£o e seguran√ßa l√≥gica, como:
   Hash de senhas (bcrypt)
   Compara√ß√µes seguras
   Cria√ß√£o/valida√ß√£o de tokens (JWT)
   Controle de permiss√µes (roles)
Exemplo:
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import userRepository from "../repositories/userRepository.js";
const SECRET = process.env.JWT_SECRET || "chave-super-secreta"; // use vari√°vel de ambiente!
async function login(email, senha) {
  const user = await userRepository.findByEmail(email);
  if (!user) {
    const error = new Error("Usu√°rio n√£o encontrado.");
    error.status = 404;
    throw error;
  }
  const senhaCorreta = await bcrypt.compare(senha, user.senha_hash);
  if (!senhaCorreta) {
    const error = new Error("Senha incorreta.");
    error.status = 401;
    throw error;
  }
  // Gera token JWT
  const token = jwt.sign(
    { id: user.id, email: user.email },
    SECRET,
    { expiresIn: "2h" }
  );
  return token;
}
export default { login };


app/repositories/ 
√â a PASTA que cont√©m os reposit√≥rios.
Cada arquivo aqui representa um "acessante de banco de dados" espec√≠fico para uma entidade (UserRepository.php, ProductRepository.php).
Eles herdam (extends) a l√≥gica b√°sica do core/Model.php e adicionam m√©todos espec√≠ficos e complexos de consulta (findUserByActiveStatus(), getProductsWithCategories()), isolando totalmente a l√≥gica de banco do resto do sistema.
Exemplo:
import db from "../database/connection.js";
async function findByEmail(email) {
  const [rows] = await db.query("SELECT * FROM usuarios WHERE email = ?", [email]);
  return rows[0]; // retorna o primeiro usu√°rio
}
export default { findByEmail };



app/controllers/
√â a PASTA que cont√©m os controladores.
Cada arquivo aqui representa um "recebedor de requisi√ß√µes HTTP" espec√≠fico (UserController.php, AuthController.php, Autentificadordelogin.php).
Eles n√£o cont√™m regras de neg√≥cio, apenas recebem os dados da web, chamam os Services necess√°rios e devolvem a resposta (JSON, HTML, redirecionamento).
Responsabilidade principal: receber requisi√ß√µes e enviar respostas HTTP.
N√£o tem l√≥gica de neg√≥cio.
Valida dados b√°sicos (ex: campos obrigat√≥rios, formatos simples de email, etc.).
Chama o Service adequado para executar a a√ß√£o.
import authService from "../services/authService.js";
Exemplo:
export async function login(req, res) {
  try {
    const { email, senha } = req.body;
    // Valida√ß√£o b√°sica de entrada
    if (!email || !senha) {
      return res.status(400).json({ error: "Email e senha s√£o obrigat√≥rios." });
    }
    const token = await authService.login(email, senha);
    return res.status(200).json({ token });
  } catch (error) {
    console.error("Erro no login:", error);
    // Erro controlado vindo do service
    if (error.status) {
      return res.status(error.status).json({ error: error.message });
    }
    // Erro inesperado
    return res.status(500).json({ error: "Erro interno do servidor." });
  }
}



core/database.php

O arquivo que configura a conex√£o √© database.php.
Database basicamente configura os metodos e conexao, tambem camufla pro repository se conectar com ele e nao com o banco direto e utilizar os metodos presentes no database.
Configura a conex√£o (SQLite/MySQL)
Oferece m√©todos prontos (insert, select, update)  
O Database.php deve ser uma camada de abstra√ß√£o gen√©rica que funciona para QUALQUER tabela. Ele oferece m√©todos gen√©ricos que os Repositories espec√≠ficos de cada entidade v√£o usar.
"Camufla" a complexidade do banco
Trocar de banco? Muda S√ì o Database.php
Repositories? Continuam IGUAIS
Controllers/Services? Nem sabem que trocou

EXEMPLO:
import mysql from "mysql2/promise";
const db = await mysql.createPool({
  host: "localhost",
  user: "root",
  password: "senha",
  database: "minha_loja"
});
export default db;

EXEMPLO:
üìç Database.php (O Fiscal do Banco)
<?php
class Database {
    private static $instance = null;
    private $connection;
    // S√ì ELE sabe como conectar
    private function __construct() {
        // Local: SQLite
        $this->connection = new PDO('sqlite:meubanco.sqlite');
        // Produ√ß√£o: MySQL (s√≥ mudar aqui)
        // $this->connection = new PDO('mysql:host=localhost;dbname=meubanco', 'user', 'senha');
    }
    // Todos pedem conex√£o por aqui
    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new Database();
        }
        return self::$instance;
    }

    // M√©todos que todos usam
    public function insert($sql, $params) {
        $stmt = $this->connection->prepare($sql);
        $stmt->execute($params);
        return $this->connection->lastInsertId();
    }
    public function fetchAll($sql, $params = []) {
        $stmt = $this->connection->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll();
    }
}




üíæ UserRepository.php (O Usu√°rio do Banco)
<?php
class UserRepository {
    private $db;
    public function __construct() {
        // Pede conex√£o pro Database (N√ÉO conecta diretamente)
        $this->db = Database::getInstance();
    }
    public function save($user) {
        // Usa os m√©todos do Database
        return $this->db->insert(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            [$user->getName(), $user->getEmail()]
        );
    }
    public function getAll() {
        // Tamb√©m usa o Database
        return $this->db->fetchAll("SELECT * FROM users");
    }
}



app/models/ 
√â a PASTA que cont√©m os objetos.
Cada arquivo aqui representa uma entidade filha concreta do seu sistema (UserModel.php, ProductModel.php).
Eles herdam (extends) a classe base Model.php para ganhar seus m√©todos prontos.


config/
√â a PASTA que cont√©m as configura√ß√µes.
Cada arquivo aqui representa um "grupo de configura√ß√µes" espec√≠fico (database.php, security.php, routes.php).
Eles centralizam todas as configura√ß√µes ajust√°veis do sistema (conex√£o com banco, chaves de seguran√ßa, defini√ß√£o de rotas) em um √∫nico lugar, facilitando a manuten√ß√£o.


config/routes.php
√â o ARQUIVO que cont√©m o mapeamento de todas as rotas.
Ele centraliza todas as defini√ß√µes de URL do sistema (/login, /products, /user/profile) e as conecta aos controllers respons√°veis.


vendor/
√â a PASTA que cont√©m as depend√™ncias.
Ela √© automaticamente gerada e gerenciada pelo Composer (ferramenta de gest√£o de pacotes PHP).
Cada subpasta aqui representa uma "biblioteca externa" instalada no projeto (como frameworks, ferramentas de email, valida√ß√£o, etc.) que seu sistema utiliza para n√£o precisar reinventar a roda.








INDEX.HTMLExemplo de index.html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minha Loja</title>

    <!-- √çcone da aba -->
    <link rel="icon" href="frontend/images/favicon.png">

    <!-- CSS -->
    <link rel="stylesheet" href="frontend/css/style.css">

    <!-- Fontes ou bibliotecas externas -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>

    <!-- Cabe√ßalho -->
    <header>
        <h1>Minha Loja</h1>
        <nav>
            <ul>
                <li><a href="#">Home</a></li>
                <li><a href="#">Produtos</a></li>
                <li><a href="#">Contato</a></li>
            </ul>
        </nav>
    </header>

    <!-- Conte√∫do principal -->
    <main>
        <section id="produtos">
            <!-- Produtos carregados via JS -->
        </section>
    </main>

    <!-- Rodap√© -->
    <footer>
        <p>¬© 2025 Minha Loja</p>
    </footer>

    <!-- Scripts -->
    <script src="frontend/js/main.js"></script>
</body>
</html>






EXEMPLO 2:

// Exemplo de chamada do front-end
fetch('/api/index.php', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'Jo√£o Silva',
        email: 'joao@email.com'
    })
})
.then(response => response.json())
.then(data => console.log(data));



1Ô∏è‚É£ Root (roteador - index php)

√â o primeiro ponto de contato do front-end.
Ele n√£o sabe nada de regras de neg√≥cio ‚Äî s√≥ recebe a requisi√ß√£o (POST, GET, etc) e decide qual controller chamar, de acordo com a ‚Äúa√ß√£o‚Äù ou rota enviada.
index.php/route
Exemplo de decis√£o dentro do root:
switch ($action) {
    case 'create':
        $controller = new UserController();
        echo json_encode($controller->create($data));
        break;
    case 'read':
        $controller = new UserController();
        echo json_encode($controller->read());
        break;
    default:
        echo json_encode(['success' => false, 'message' => 'A√ß√£o inv√°lida']);
}



2Ô∏è‚É£ Controller
Recebe os dados do root.
√â respons√°vel por validar superficialmente os dados (tipo: campos obrigat√≥rios).
Decide qual service chamar para tratar a regra de neg√≥cio.
Exemplo:
class UserController {
    private $service;

    public function __construct() {
        $this->service = new UserService();
    }

    public function create($data) {
        return $this->service->createUser($data['name'], $data['email']);
    }
}



3Ô∏è‚É£ Service
Cont√©m toda a l√≥gica de neg√≥cio.
Recebe dados do controller, aplica regras, valida√ß√µes mais complexas, formata objetos.
Decide qual repository usar para persistir ou consultar dados.
Exemplo:
class UserService {
    private $repository;

    public function __construct() {
        $this->repository = new UserRepository();
    }

    public function createUser($name, $email) {
        if (empty($name) || empty($email)) {
            return ['success' => false, 'message' => 'Nome e email s√£o obrigat√≥rios'];
        }
        return $this->repository->create($name, $email)
            ? ['success' => true, 'message' => 'Usu√°rio criado com sucesso']
            : ['success' => false, 'message' => 'Erro ao criar usu√°rio'];
    }
}



4Ô∏è‚É£ Repository
√â respons√°vel por interagir com a camada de dados (Database).
S√≥ salva, consulta, atualiza ou deleta dados.
N√£o cont√©m regra de neg√≥cio.
Exemplo:
class UserRepository {
    private $db;
    public function __construct() {
        $this->db = Database::getInstance();
    }
    public function create($name, $email) {
        $data = $this->db->getData();
        $data['users'][] = [
            'id' => time(),
            'name' => $name,
            'email' => $email
        ];
        return $this->db->saveData($data);
    }
}



5Ô∏è‚É£ Database
Abstrai onde os dados ficam (JSON, MySQL, etc).
O repository chama o Database, mas o Service nunca fala direto com o Database.
‚úÖ Resumo do fluxo
Front-end ---> Root (roteador) ---> Controller ---> Service ---> Repository ---> Database
Root: decide qual controller chamar
Controller: valida dados e escolhe o service
Service: aplica regras de neg√≥cio e escolhe o repository
Repository: salva ou l√™ dados no database
Database: gerencia o armazenamento real











----------------------------------------------------------------------------------------------------------------------------------------





                                        -CONCEITOS DE DESENVOLVIMENTO EM CODIGO-



POO E OUTROS:

1. CLASSE NORMAL
<?php 
class Usuario {
    public $nome;

    public function __construct($nome) {
        $this->nome = $nome;
    }

    public function mostrar() {
        return "Ol√°, " . $this->nome;
    }
}
$u = new Usuario("Kaito");
echo $u->mostrar(); // Ol√°, Kaito




2. ENCAPSULAMENTO
Controlar acesso com private, protected, public.
<?php
class Conta {
    private $saldo = 0;

    public function depositar($v) { $this->saldo += $v; }
    public function verSaldo() { return $this->saldo; }
}
$c = new Conta();
$c->depositar(100);
echo $c->verSaldo(); // 100




3. HERAN√áA
Uma classe herda de outra.
<?php
class Pessoa {
    public $nome;
    public function __construct($n) { $this->nome = $n; }
}
class Funcionario extends Pessoa {
    public function cargo() { return "$this->nome √© funcion√°rio"; }
}
$f = new Funcionario("Ana");
echo $f->cargo(); // Ana √© funcion√°rio




4. POLIMORFISMO

Polimorfismo com interface:
Cada classe implementa a mesma interface, mas com comportamento diferente.
<?php
interface Forma {
    public function area();
}
class Quadrado implements Forma {
    public function area() { return 4 * 4; }
}
class Circulo implements Forma {
    public function area() { return 3.14 * 3 * 3; }
}
$formas = [new Quadrado(), new Circulo()];
foreach ($formas as $f) {
    echo $f->area() . "\n"; // cada um responde de forma diferente
}


Polimorfismo com heran√ßa
Uma classe filha herda da pai e reimplementa (sobrescreve) o m√©todo.
<?php
class Animal {
    public function som() {
        return "Som gen√©rico";
    }
}
class Cachorro extends Animal {
    public function som() {
        return "Au au!";
    }
}
class Gato extends Animal {
    public function som() {
        return "Miau!";
    }
}
$animais = [new Cachorro(), new Gato()];
foreach ($animais as $a) {
    echo $a->som() . "\n"; // Au au! / Miau!
}




4. COMPOSI√áAO
Uma classe usa outra como parte dela.
<?php
class Motor {
    public function ligar() { return "Motor ligado"; }
}
class Carro {
    private $motor;
    public function __construct() { $this->motor = new Motor(); }
    public function andar() { return $this->motor->ligar()." e carro andando"; }
}
$c = new Carro();
echo $c->andar(); // Motor ligado e carro andando




5. CLASSE ABSTRATA
<?php
abstract class Animal {
    abstract public function som();
}
class Cachorro extends Animal {
    public function som() {
        return "Au au!";
    }
}
$dog = new Cachorro();
echo $dog->som(); // Au au!




6. CLASSE ANONIMA
<?php
$carro = new class {
    public $marca = "Toyota";
    public function info() {
        return "Marca: " . $this->marca;
    }
};
echo $carro->info(); // Marca: Toyota




7. INTERFACE
//uma classe pode implementar quantas interfaces quiser, diferente de heran√ßa normal
//pode ter atributos abstratos dentro dela obrigando a implementa√ßao, ou opcionais, mas independente se uma classe implementa uma interface deve implementar tudo qo for abstrato
<?php
interface Pagamento {
    public function pagar($valor);
}
class Boleto implements Pagamento { 
    public function pagar($valor) {
        return "Pago R$ $valor com boleto.";
    }
}
$p = new Boleto();
echo $p->pagar(100);















---------------------------------------------------------------------------------------------------------------------------------------------










                                                   --CONECTANDO FT E BACK / BACK E BC--





                             -BACK E FRONT-


O "roadmap de conex√£o" entre Front-End e Back-End nada mais √© do que seguir uma estrutura l√≥gica no c√≥digo.


üîß COMO FUNCIONA
- O Front-End usa fetch ou form para enviar requisi√ß√µes HTTP (GET, POST...) para o Back-End.
- O Back-End √© uma API RESTful, que responde em JSON, consultando o banco de dados usando drivers como mysql2, mongoose, pg, etc.

API RESTful permite que o Front-End se comunique com o Back-End via requisi√ß√µes HTTP.
Os principais m√©todos HTTP:
GET ‚Üí Buscar dados
POST ‚Üí Enviar/criar dados
PUT ‚Üí Atualizar dados
DELETE ‚Üí Remover dados

A resposta geralmente √© em JSON, um formato leve e f√°cil de usar no JavaScript.
O front (HTML, JS, React, etc.) faz requisi√ß√µes HTTP usando fetch(), axios ou bibliotecas similares.
Ele recebe a resposta da API e exibe os dados na interface.



‚ö™‚ö™‚ö™ EXEMPLO PRATICO:

üîÅBACK END- api.php
<?php
header("Access-Control-Allow-Origin: *");
header("Content-Type: application/json");
$usuarios = [
    ["id" => 1, "nome" => "Maria"],
    ["id" => 2, "nome" => "Jo√£o"]
];
echo json_encode($usuarios);

Essa API:
Aceita requisi√ß√µes HTTP GET
Retorna um JSON com os dados dos usu√°rios
Permite CORS para que o front consiga acessar

üåêFRONT-END (index.html)
<!DOCTYPE html>
<html>
<head>
  <title>Consumindo API em PHP</title>
</head>
<body>
  <h1>Lista de Usu√°rios</h1>
  <ul id="usuarios"></ul>
  <script>//JAVASCRIPT
    fetch('http://localhost/api.php')
      .then(res => res.json())
      .then(data => {
        const ul = document.getElementById('usuarios');
        data.forEach(usuario => {
          const li = document.createElement('li');
          li.innerText = usuario.nome;
          ul.appendChild(li);
        });
      })
      .catch(err => console.error("Erro ao buscar API:", err));
  </script>
</body>
</html>

O que esse exemplo demonstra (igual ao do Node.js):
   Requisi√ß√£o do front-end usando fetch()
   Resposta da API PHP com JSON
   Manipula√ß√£o no front-end (DOM) com os dados recebidos
   Funciona 100% local com XAMPP, Laragon, ou qualquer servidor PHP






----





                             -BACK E BC-

   
A conex√£o entre o backend e o banco de dados segue uma arquitetura em camadas bem definida, onde cada parte tem responsabilidades espec√≠ficas:
O Database atua como a funda√ß√£o - √© a √∫nica camada que realmente conhece e interage diretamente com o banco de dados. Ele abstrai toda a complexidade das conex√µes, seja SQLite para desenvolvimento ou MySQL para produ√ß√£o.
Os Repositories funcionam como intermedi√°rios especializados - cada entidade do sistema (usu√°rios, produtos) tem seu repository que traduz as opera√ß√µes de neg√≥cio em comandos espec√≠ficos do banco, usando os m√©todos padronizados fornecidos pelo Database.
Os Controllers mant√™m dist√¢ncia do banco - sua fun√ß√£o √© lidar com requisi√ß√µes HTTP e respostas, delegando toda a l√≥gica de dados para camadas mais internas. Eles s√£o os "porta-vozes" do sistema, focados em comunica√ß√£o externa.
Essa separa√ß√£o cria um fluxo claro: requisi√ß√µes entram pelos controllers, passam pelos services para valida√ß√µes de neg√≥cio, s√£o convertidas em opera√ß√µes de banco pelos repositories, e finalmente executadas pelo database. O resultado √© um sistema onde mudan√ßas no banco afetam apenas o database, mudan√ßas nas queries afetam apenas os repositories, e o restante do c√≥digo permanece intacto.
//üîπ Se o backend e o MySQL est√£o na mesma m√°quina ‚Üí basta usar localhost ou 127.0.0.1, n√£o precisa liberar IP nem firewall.
//üîπ Se o backend roda em um servidor e o MySQL em outro ‚Üí a√≠ sim precisa liberar o host/IP (ou usar t√∫nel SSH/VPN) para que um consiga se conectar ao outro.


// √öNICO que conhece o banco intimamente
class Database {
    // Sabe todos os segredos da conex√£o
    // Fala a l√≠ngua do banco (SQLite, MySQL)
    // Oferece m√©todos de comunica√ß√£o
}



// Usa o "database" para se comunicar
class UserRepository {
    private $db; // Tem o Database como parceiro
    public function save($user) {
        // N√£o precisa saber COMO funciona, s√≥ PEDE
        return $this->db->insert("INSERT...", [$dados]);
    }
}


class UserController {
    public function create() {
        // N√£o sabe NADA sobre banco
        // S√≥ recebe dados e pede pro Service
        $user = $this->userService->create($dados);
        return $this->json($user); // S√≥ formata resposta
    }







             -RESUMO SIMPLES DE RELACIONAMENTO PRATICO-

No servidor de banco (HostGator, no caso):
Cria um usu√°rio espec√≠fico do MySQL (n√£o usar o root).
D√° permiss√£o de acesso apenas ao banco que ele vai usar (GRANT ALL PRIVILEGES ON meu_banco.* TO 'usuario_backend'@'%' IDENTIFIED BY 'senha_forte';).
Se poss√≠vel, restringe ainda mais o host ('meuip'@'%' ou 'meuip'@'meu.dominio.com').

No seu projeto backend (PHP):
Voc√™ cria um arquivo de configura√ß√£o (database.php, .env, ou similar).
Nesse arquivo ficam as credenciais sens√≠veis (host, usu√°rio, senha, nome do banco).
Exemplo simples (database.php):
<?php
return [
    'host' => 'meudominio.com',
    'user' => 'usuario_backend',
    'password' => 'senha_forte',
    'database' => 'meu_banco'
];


E no c√≥digo que conecta:
$config = require __DIR__ . '/database.php';
$conn = new mysqli(
    $config['host'],
    $config['user'],
    $config['password'],
    $config['database']
);
if ($conn->connect_error) {
    die("Erro na conex√£o: " . $conn->connect_error);
}




